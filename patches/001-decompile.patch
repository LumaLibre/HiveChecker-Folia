diff --git a/dev/hexedhero/hivechecker/HiveChecker.java b/dev/hexedhero/hivechecker/HiveChecker.java
index d69a6fb..b08ce69 100644
--- a/dev/hexedhero/hivechecker/HiveChecker.java
+++ b/dev/hexedhero/hivechecker/HiveChecker.java
@@ -4,7 +4,8 @@ import dev.hexedhero.hivechecker.commands.HiveCheckerCommand;
 import dev.hexedhero.hivechecker.listeners.HiveListener;
 import dev.hexedhero.hivechecker.listeners.InventoryListener;
 import dev.hexedhero.hivechecker.managers.InventoryManager;
-import dev.hexedhero.hivechecker.shaded.bstats.bukkit.Metrics;
+//import dev.hexedhero.hivechecker.shaded.bstats.bukkit.Metrics; // Luma - decompile
+import org.bstats.bukkit.Metrics; // Luma - decompile
 import dev.hexedhero.hivechecker.utils.Common;
 import dev.hexedhero.hivechecker.utils.PluginInformation;
 import dev.hexedhero.hivechecker.utils.RegistrationHelper;
diff --git a/dev/hexedhero/hivechecker/shaded/bstats/MetricsBase.java b/dev/hexedhero/hivechecker/shaded/bstats/MetricsBase.java
deleted file mode 100644
index 354dfb9..0000000
--- a/dev/hexedhero/hivechecker/shaded/bstats/MetricsBase.java
+++ /dev/null
@@ -1,229 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.bstats;
-
-import dev.hexedhero.hivechecker.shaded.bstats.charts.CustomChart;
-import dev.hexedhero.hivechecker.shaded.bstats.json.JsonObjectBuilder;
-import java.io.BufferedReader;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.net.URL;
-import java.nio.charset.StandardCharsets;
-import java.util.HashSet;
-import java.util.Objects;
-import java.util.Set;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.function.BiConsumer;
-import java.util.function.Consumer;
-import java.util.function.Supplier;
-import java.util.zip.GZIPOutputStream;
-import javax.net.ssl.HttpsURLConnection;
-
-public class MetricsBase {
-   public static final String METRICS_VERSION = "3.1.0";
-   private static final String REPORT_URL = "https://bStats.org/api/v2/data/%s";
-   private final ScheduledExecutorService scheduler;
-   private final String platform;
-   private final String serverUuid;
-   private final int serviceId;
-   private final Consumer<JsonObjectBuilder> appendPlatformDataConsumer;
-   private final Consumer<JsonObjectBuilder> appendServiceDataConsumer;
-   private final Consumer<Runnable> submitTaskConsumer;
-   private final Supplier<Boolean> checkServiceEnabledSupplier;
-   private final BiConsumer<String, Throwable> errorLogger;
-   private final Consumer<String> infoLogger;
-   private final boolean logErrors;
-   private final boolean logSentData;
-   private final boolean logResponseStatusText;
-   private final Set<CustomChart> customCharts = new HashSet<>();
-   private final boolean enabled;
-
-   public MetricsBase(
-      String platform,
-      String serverUuid,
-      int serviceId,
-      boolean enabled,
-      Consumer<JsonObjectBuilder> appendPlatformDataConsumer,
-      Consumer<JsonObjectBuilder> appendServiceDataConsumer,
-      Consumer<Runnable> submitTaskConsumer,
-      Supplier<Boolean> checkServiceEnabledSupplier,
-      BiConsumer<String, Throwable> errorLogger,
-      Consumer<String> infoLogger,
-      boolean logErrors,
-      boolean logSentData,
-      boolean logResponseStatusText,
-      boolean skipRelocateCheck
-   ) {
-      ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(1, task -> {
-         Thread thread = new Thread(task, "bStats-Metrics");
-         thread.setDaemon(true);
-         return thread;
-      });
-      scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
-      this.scheduler = scheduler;
-      this.platform = platform;
-      this.serverUuid = serverUuid;
-      this.serviceId = serviceId;
-      this.enabled = enabled;
-      this.appendPlatformDataConsumer = appendPlatformDataConsumer;
-      this.appendServiceDataConsumer = appendServiceDataConsumer;
-      this.submitTaskConsumer = submitTaskConsumer;
-      this.checkServiceEnabledSupplier = checkServiceEnabledSupplier;
-      this.errorLogger = errorLogger;
-      this.infoLogger = infoLogger;
-      this.logErrors = logErrors;
-      this.logSentData = logSentData;
-      this.logResponseStatusText = logResponseStatusText;
-      if (!skipRelocateCheck) {
-         this.checkRelocation();
-      }
-
-      if (enabled) {
-         this.startSubmitting();
-      }
-   }
-
-   public void addCustomChart(CustomChart chart) {
-      this.customCharts.add(chart);
-   }
-
-   public void shutdown() {
-      this.scheduler.shutdown();
-   }
-
-   private void startSubmitting() {
-      Runnable submitTask = () -> {
-         if (this.enabled && this.checkServiceEnabledSupplier.get()) {
-            if (this.submitTaskConsumer != null) {
-               this.submitTaskConsumer.accept(this::submitData);
-            } else {
-               this.submitData();
-            }
-         } else {
-            this.scheduler.shutdown();
-         }
-      };
-      long initialDelay = (long)(60000.0 * (3.0 + Math.random() * 3.0));
-      long secondDelay = (long)(60000.0 * (Math.random() * 30.0));
-      this.scheduler.schedule(submitTask, initialDelay, TimeUnit.MILLISECONDS);
-      this.scheduler.scheduleAtFixedRate(submitTask, initialDelay + secondDelay, 1800000L, TimeUnit.MILLISECONDS);
-   }
-
-   private void submitData() {
-      JsonObjectBuilder baseJsonBuilder = new JsonObjectBuilder();
-      this.appendPlatformDataConsumer.accept(baseJsonBuilder);
-      JsonObjectBuilder serviceJsonBuilder = new JsonObjectBuilder();
-      this.appendServiceDataConsumer.accept(serviceJsonBuilder);
-      JsonObjectBuilder.JsonObject[] chartData = this.customCharts
-         .stream()
-         .map(customChart -> customChart.getRequestJsonObject(this.errorLogger, this.logErrors))
-         .filter(Objects::nonNull)
-         .toArray(JsonObjectBuilder.JsonObject[]::new);
-      serviceJsonBuilder.appendField("id", this.serviceId);
-      serviceJsonBuilder.appendField("customCharts", chartData);
-      baseJsonBuilder.appendField("service", serviceJsonBuilder.build());
-      baseJsonBuilder.appendField("serverUUID", this.serverUuid);
-      baseJsonBuilder.appendField("metricsVersion", "3.1.0");
-      JsonObjectBuilder.JsonObject data = baseJsonBuilder.build();
-      this.scheduler.execute(() -> {
-         try {
-            this.sendData(data);
-         } catch (Exception var3x) {
-            if (this.logErrors) {
-               this.errorLogger.accept("Could not submit bStats metrics data", var3x);
-            }
-         }
-      });
-   }
-
-   private void sendData(JsonObjectBuilder.JsonObject data) throws Exception {
-      if (this.logSentData) {
-         this.infoLogger.accept("Sent bStats metrics data: " + data.toString());
-      }
-
-      String url = String.format("https://bStats.org/api/v2/data/%s", this.platform);
-      HttpsURLConnection connection = (HttpsURLConnection)new URL(url).openConnection();
-      byte[] compressedData = compress(data.toString());
-      connection.setRequestMethod("POST");
-      connection.addRequestProperty("Accept", "application/json");
-      connection.addRequestProperty("Connection", "close");
-      connection.addRequestProperty("Content-Encoding", "gzip");
-      connection.addRequestProperty("Content-Length", String.valueOf(compressedData.length));
-      connection.setRequestProperty("Content-Type", "application/json");
-      connection.setRequestProperty("User-Agent", "Metrics-Service/1");
-      connection.setDoOutput(true);
-      DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream());
-
-      try {
-         outputStream.write(compressedData);
-      } catch (Throwable var11) {
-         try {
-            outputStream.close();
-         } catch (Throwable var10) {
-            var11.addSuppressed(var10);
-         }
-
-         throw var11;
-      }
-
-      outputStream.close();
-      StringBuilder var13 = new StringBuilder();
-      BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
-
-      String line;
-      try {
-         while ((line = bufferedReader.readLine()) != null) {
-            var13.append(line);
-         }
-      } catch (Throwable var12) {
-         try {
-            bufferedReader.close();
-         } catch (Throwable var9) {
-            var12.addSuppressed(var9);
-         }
-
-         throw var12;
-      }
-
-      bufferedReader.close();
-      if (this.logResponseStatusText) {
-         this.infoLogger.accept("Sent data to bStats and received response: " + var13);
-      }
-   }
-
-   private void checkRelocation() {
-      if (System.getProperty("bstats.relocatecheck") == null || !System.getProperty("bstats.relocatecheck").equals("false")) {
-         String defaultPackage = new String(new byte[]{111, 114, 103, 46, 98, 115, 116, 97, 116, 115});
-         String examplePackage = new String(new byte[]{121, 111, 117, 114, 46, 112, 97, 99, 107, 97, 103, 101});
-         if (MetricsBase.class.getPackage().getName().startsWith(defaultPackage) || MetricsBase.class.getPackage().getName().startsWith(examplePackage)) {
-            throw new IllegalStateException("bStats Metrics class has not been relocated correctly!");
-         }
-      }
-   }
-
-   private static byte[] compress(String str) throws IOException {
-      if (str == null) {
-         return null;
-      } else {
-         ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-         GZIPOutputStream gzip = new GZIPOutputStream(outputStream);
-
-         try {
-            gzip.write(str.getBytes(StandardCharsets.UTF_8));
-         } catch (Throwable var6) {
-            try {
-               gzip.close();
-            } catch (Throwable var5) {
-               var6.addSuppressed(var5);
-            }
-
-            throw var6;
-         }
-
-         gzip.close();
-         return outputStream.toByteArray();
-      }
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/bstats/bukkit/Metrics.java b/dev/hexedhero/hivechecker/shaded/bstats/bukkit/Metrics.java
deleted file mode 100644
index ecda461..0000000
--- a/dev/hexedhero/hivechecker/shaded/bstats/bukkit/Metrics.java
+++ /dev/null
@@ -1,108 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.bstats.bukkit;
-
-import dev.hexedhero.hivechecker.shaded.bstats.MetricsBase;
-import dev.hexedhero.hivechecker.shaded.bstats.charts.CustomChart;
-import dev.hexedhero.hivechecker.shaded.bstats.json.JsonObjectBuilder;
-import java.io.File;
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.util.Collection;
-import java.util.UUID;
-import java.util.logging.Level;
-import org.bukkit.Bukkit;
-import org.bukkit.configuration.file.YamlConfiguration;
-import org.bukkit.entity.Player;
-import org.bukkit.plugin.Plugin;
-
-public class Metrics {
-   private final Plugin plugin;
-   private final MetricsBase metricsBase;
-
-   public Metrics(Plugin plugin, int serviceId) {
-      this.plugin = plugin;
-      File bStatsFolder = new File(plugin.getDataFolder().getParentFile(), "bStats");
-      File configFile = new File(bStatsFolder, "config.yml");
-      YamlConfiguration config = YamlConfiguration.loadConfiguration(configFile);
-      if (!config.isSet("serverUuid")) {
-         config.addDefault("enabled", true);
-         config.addDefault("serverUuid", UUID.randomUUID().toString());
-         config.addDefault("logFailedRequests", false);
-         config.addDefault("logSentData", false);
-         config.addDefault("logResponseStatusText", false);
-         config.options()
-            .header(
-               "bStats (https://bStats.org) collects some basic information for plugin authors, like how\nmany people use their plugin and their total player count. It's recommended to keep bStats\nenabled, but if you're not comfortable with this, you can turn this setting off. There is no\nperformance penalty associated with having metrics enabled, and data sent to bStats is fully\nanonymous."
-            )
-            .copyDefaults(true);
-
-         try {
-            config.save(configFile);
-         } catch (IOException var14) {
-         }
-      }
-
-      boolean enabled = config.getBoolean("enabled", true);
-      String serverUUID = config.getString("serverUuid");
-      boolean logErrors = config.getBoolean("logFailedRequests", false);
-      boolean logSentData = config.getBoolean("logSentData", false);
-      boolean logResponseStatusText = config.getBoolean("logResponseStatusText", false);
-      boolean isFolia = false;
-
-      try {
-         isFolia = Class.forName("io.papermc.paper.threadedregions.RegionizedServer") != null;
-      } catch (Exception var13) {
-      }
-
-      this.metricsBase = new MetricsBase(
-         "bukkit",
-         serverUUID,
-         serviceId,
-         enabled,
-         this::appendPlatformData,
-         this::appendServiceData,
-         isFolia ? null : submitDataTask -> Bukkit.getScheduler().runTask(plugin, submitDataTask),
-         plugin::isEnabled,
-         (message, error) -> this.plugin.getLogger().log(Level.WARNING, message, error),
-         message -> this.plugin.getLogger().log(Level.INFO, message),
-         logErrors,
-         logSentData,
-         logResponseStatusText,
-         false
-      );
-   }
-
-   public void shutdown() {
-      this.metricsBase.shutdown();
-   }
-
-   public void addCustomChart(CustomChart chart) {
-      this.metricsBase.addCustomChart(chart);
-   }
-
-   private void appendPlatformData(JsonObjectBuilder builder) {
-      builder.appendField("playerAmount", this.getPlayerAmount());
-      builder.appendField("onlineMode", Bukkit.getOnlineMode() ? 1 : 0);
-      builder.appendField("bukkitVersion", Bukkit.getVersion());
-      builder.appendField("bukkitName", Bukkit.getName());
-      builder.appendField("javaVersion", System.getProperty("java.version"));
-      builder.appendField("osName", System.getProperty("os.name"));
-      builder.appendField("osArch", System.getProperty("os.arch"));
-      builder.appendField("osVersion", System.getProperty("os.version"));
-      builder.appendField("coreCount", Runtime.getRuntime().availableProcessors());
-   }
-
-   private void appendServiceData(JsonObjectBuilder builder) {
-      builder.appendField("pluginVersion", this.plugin.getDescription().getVersion());
-   }
-
-   private int getPlayerAmount() {
-      try {
-         Method onlinePlayersMethod = Class.forName("org.bukkit.Server").getMethod("getOnlinePlayers");
-         return onlinePlayersMethod.getReturnType().equals(Collection.class)
-            ? ((Collection)onlinePlayersMethod.invoke(Bukkit.getServer())).size()
-            : ((Player[])onlinePlayersMethod.invoke(Bukkit.getServer())).length;
-      } catch (Exception var2) {
-         return Bukkit.getOnlinePlayers().size();
-      }
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/bstats/charts/CustomChart.java b/dev/hexedhero/hivechecker/shaded/bstats/charts/CustomChart.java
deleted file mode 100644
index 1001c6a..0000000
--- a/dev/hexedhero/hivechecker/shaded/bstats/charts/CustomChart.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.bstats.charts;
-
-import dev.hexedhero.hivechecker.shaded.bstats.json.JsonObjectBuilder;
-import java.util.function.BiConsumer;
-
-public abstract class CustomChart {
-   private final String chartId;
-
-   protected CustomChart(String chartId) {
-      if (chartId == null) {
-         throw new IllegalArgumentException("chartId must not be null");
-      } else {
-         this.chartId = chartId;
-      }
-   }
-
-   public JsonObjectBuilder.JsonObject getRequestJsonObject(BiConsumer<String, Throwable> errorLogger, boolean logErrors) {
-      JsonObjectBuilder builder = new JsonObjectBuilder();
-      builder.appendField("chartId", this.chartId);
-
-      try {
-         JsonObjectBuilder.JsonObject data = this.getChartData();
-         if (data == null) {
-            return null;
-         }
-
-         builder.appendField("data", data);
-      } catch (Throwable var5) {
-         if (logErrors) {
-            errorLogger.accept("Failed to get data for custom chart with id " + this.chartId, var5);
-         }
-
-         return null;
-      }
-
-      return builder.build();
-   }
-
-   protected abstract JsonObjectBuilder.JsonObject getChartData() throws Exception;
-}
diff --git a/dev/hexedhero/hivechecker/shaded/bstats/json/JsonObjectBuilder.java b/dev/hexedhero/hivechecker/shaded/bstats/json/JsonObjectBuilder.java
deleted file mode 100644
index 2b299ca..0000000
--- a/dev/hexedhero/hivechecker/shaded/bstats/json/JsonObjectBuilder.java
+++ /dev/null
@@ -1,130 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.bstats.json;
-
-import java.util.Arrays;
-import java.util.stream.Collectors;
-
-public class JsonObjectBuilder {
-   private StringBuilder builder = new StringBuilder();
-   private boolean hasAtLeastOneField = false;
-
-   public JsonObjectBuilder() {
-      this.builder.append("{");
-   }
-
-   public JsonObjectBuilder appendNull(String key) {
-      this.appendFieldUnescaped(key, "null");
-      return this;
-   }
-
-   public JsonObjectBuilder appendField(String key, String value) {
-      if (value == null) {
-         throw new IllegalArgumentException("JSON value must not be null");
-      } else {
-         this.appendFieldUnescaped(key, "\"" + escape(value) + "\"");
-         return this;
-      }
-   }
-
-   public JsonObjectBuilder appendField(String key, int value) {
-      this.appendFieldUnescaped(key, String.valueOf(value));
-      return this;
-   }
-
-   public JsonObjectBuilder appendField(String key, JsonObjectBuilder.JsonObject object) {
-      if (object == null) {
-         throw new IllegalArgumentException("JSON object must not be null");
-      } else {
-         this.appendFieldUnescaped(key, object.toString());
-         return this;
-      }
-   }
-
-   public JsonObjectBuilder appendField(String key, String[] values) {
-      if (values == null) {
-         throw new IllegalArgumentException("JSON values must not be null");
-      } else {
-         String escapedValues = Arrays.stream(values).map(value -> "\"" + escape(value) + "\"").collect(Collectors.joining(","));
-         this.appendFieldUnescaped(key, "[" + escapedValues + "]");
-         return this;
-      }
-   }
-
-   public JsonObjectBuilder appendField(String key, int[] values) {
-      if (values == null) {
-         throw new IllegalArgumentException("JSON values must not be null");
-      } else {
-         String escapedValues = Arrays.stream(values).mapToObj(String::valueOf).collect(Collectors.joining(","));
-         this.appendFieldUnescaped(key, "[" + escapedValues + "]");
-         return this;
-      }
-   }
-
-   public JsonObjectBuilder appendField(String key, JsonObjectBuilder.JsonObject[] values) {
-      if (values == null) {
-         throw new IllegalArgumentException("JSON values must not be null");
-      } else {
-         String escapedValues = Arrays.stream(values).map(JsonObjectBuilder.JsonObject::toString).collect(Collectors.joining(","));
-         this.appendFieldUnescaped(key, "[" + escapedValues + "]");
-         return this;
-      }
-   }
-
-   private void appendFieldUnescaped(String key, String escapedValue) {
-      if (this.builder == null) {
-         throw new IllegalStateException("JSON has already been built");
-      } else if (key == null) {
-         throw new IllegalArgumentException("JSON key must not be null");
-      } else {
-         if (this.hasAtLeastOneField) {
-            this.builder.append(",");
-         }
-
-         this.builder.append("\"").append(escape(key)).append("\":").append(escapedValue);
-         this.hasAtLeastOneField = true;
-      }
-   }
-
-   public JsonObjectBuilder.JsonObject build() {
-      if (this.builder == null) {
-         throw new IllegalStateException("JSON has already been built");
-      } else {
-         JsonObjectBuilder.JsonObject object = new JsonObjectBuilder.JsonObject(this.builder.append("}").toString());
-         this.builder = null;
-         return object;
-      }
-   }
-
-   private static String escape(String value) {
-      StringBuilder builder = new StringBuilder();
-
-      for (int i = 0; i < value.length(); i++) {
-         char c = value.charAt(i);
-         if (c == '"') {
-            builder.append("\\\"");
-         } else if (c == '\\') {
-            builder.append("\\\\");
-         } else if (c <= 15) {
-            builder.append("\\u000").append(Integer.toHexString(c));
-         } else if (c <= 31) {
-            builder.append("\\u00").append(Integer.toHexString(c));
-         } else {
-            builder.append(c);
-         }
-      }
-
-      return builder.toString();
-   }
-
-   public static class JsonObject {
-      private final String value;
-
-      private JsonObject(String value) {
-         this.value = value;
-      }
-
-      @Override
-      public String toString() {
-         return this.value;
-      }
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/JSONArray.java b/dev/hexedhero/hivechecker/shaded/json/JSONArray.java
deleted file mode 100644
index 8cf130b..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/JSONArray.java
+++ /dev/null
@@ -1,845 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.lang.reflect.Array;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-public class JSONArray implements Iterable<Object> {
-   private final ArrayList<Object> myArrayList;
-
-   public JSONArray() {
-      this.myArrayList = new ArrayList<>();
-   }
-
-   public JSONArray(JSONTokener x) throws JSONException {
-      this(x, x.getJsonParserConfiguration());
-   }
-
-   public JSONArray(JSONTokener x, JSONParserConfiguration jsonParserConfiguration) throws JSONException {
-      this();
-      boolean isInitial = x.getPrevious() == 0;
-      if (x.nextClean() != '[') {
-         throw x.syntaxError("A JSONArray text must start with '['");
-      } else {
-         char nextChar = x.nextClean();
-         if (nextChar == 0) {
-            throw x.syntaxError("Expected a ',' or ']'");
-         } else if (nextChar != ']') {
-            x.back();
-
-            while (true) {
-               if (x.nextClean() == ',') {
-                  x.back();
-                  this.myArrayList.add(JSONObject.NULL);
-               } else {
-                  x.back();
-                  this.myArrayList.add(x.nextValue());
-               }
-
-               switch (x.nextClean()) {
-                  case '\u0000':
-                     throw x.syntaxError("Expected a ',' or ']'");
-                  case ',':
-                     nextChar = x.nextClean();
-                     if (nextChar == 0) {
-                        throw x.syntaxError("Expected a ',' or ']'");
-                     }
-
-                     if (nextChar == ']') {
-                        if (jsonParserConfiguration.isStrictMode()) {
-                           throw x.syntaxError("Strict mode error: Expected another array element");
-                        }
-
-                        return;
-                     }
-
-                     if (nextChar == ',') {
-                        if (jsonParserConfiguration.isStrictMode()) {
-                           throw x.syntaxError("Strict mode error: Expected a valid array element");
-                        }
-
-                        return;
-                     }
-
-                     x.back();
-                     break;
-                  case ']':
-                     if (isInitial && jsonParserConfiguration.isStrictMode() && x.nextClean() != 0) {
-                        throw x.syntaxError("Strict mode error: Unparsed characters found at end of input text");
-                     }
-
-                     return;
-                  default:
-                     throw x.syntaxError("Expected a ',' or ']'");
-               }
-            }
-         } else if (isInitial && jsonParserConfiguration.isStrictMode() && x.nextClean() != 0) {
-            throw x.syntaxError("Strict mode error: Unparsed characters found at end of input text");
-         }
-      }
-   }
-
-   public JSONArray(String source) throws JSONException {
-      this(source, new JSONParserConfiguration());
-   }
-
-   public JSONArray(String source, JSONParserConfiguration jsonParserConfiguration) throws JSONException {
-      this(new JSONTokener(source, jsonParserConfiguration), jsonParserConfiguration);
-   }
-
-   public JSONArray(Collection<?> collection) {
-      this(collection, 0, new JSONParserConfiguration());
-   }
-
-   public JSONArray(Collection<?> collection, JSONParserConfiguration jsonParserConfiguration) {
-      this(collection, 0, jsonParserConfiguration);
-   }
-
-   JSONArray(Collection<?> collection, int recursionDepth, JSONParserConfiguration jsonParserConfiguration) {
-      if (recursionDepth > jsonParserConfiguration.getMaxNestingDepth()) {
-         throw new JSONException("JSONArray has reached recursion depth limit of " + jsonParserConfiguration.getMaxNestingDepth());
-      } else {
-         if (collection == null) {
-            this.myArrayList = new ArrayList<>();
-         } else {
-            this.myArrayList = new ArrayList<>(collection.size());
-            this.addAll(collection, true, recursionDepth, jsonParserConfiguration);
-         }
-      }
-   }
-
-   public JSONArray(Iterable<?> iter) {
-      this();
-      if (iter != null) {
-         this.addAll(iter, true);
-      }
-   }
-
-   public JSONArray(JSONArray array) {
-      if (array == null) {
-         this.myArrayList = new ArrayList<>();
-      } else {
-         this.myArrayList = new ArrayList<>(array.myArrayList);
-      }
-   }
-
-   public JSONArray(Object array) throws JSONException {
-      this();
-      if (!array.getClass().isArray()) {
-         throw new JSONException("JSONArray initial value should be a string or collection or array.");
-      } else {
-         this.addAll(array, true, 0);
-      }
-   }
-
-   public JSONArray(int initialCapacity) throws JSONException {
-      if (initialCapacity < 0) {
-         throw new JSONException("JSONArray initial capacity cannot be negative.");
-      } else {
-         this.myArrayList = new ArrayList<>(initialCapacity);
-      }
-   }
-
-   @Override
-   public Iterator<Object> iterator() {
-      return this.myArrayList.iterator();
-   }
-
-   public Object get(int index) throws JSONException {
-      Object object = this.opt(index);
-      if (object == null) {
-         throw new JSONException("JSONArray[" + index + "] not found.");
-      } else {
-         return object;
-      }
-   }
-
-   public boolean getBoolean(int index) throws JSONException {
-      Object object = this.get(index);
-      if (!object.equals(Boolean.FALSE) && (!(object instanceof String) || !((String)object).equalsIgnoreCase("false"))) {
-         if (!object.equals(Boolean.TRUE) && (!(object instanceof String) || !((String)object).equalsIgnoreCase("true"))) {
-            throw wrongValueFormatException(index, "boolean", object, null);
-         } else {
-            return true;
-         }
-      } else {
-         return false;
-      }
-   }
-
-   public double getDouble(int index) throws JSONException {
-      Object object = this.get(index);
-      if (object instanceof Number) {
-         return ((Number)object).doubleValue();
-      } else {
-         try {
-            return Double.parseDouble(object.toString());
-         } catch (Exception var4) {
-            throw wrongValueFormatException(index, "double", object, var4);
-         }
-      }
-   }
-
-   public float getFloat(int index) throws JSONException {
-      Object object = this.get(index);
-      if (object instanceof Number) {
-         return ((Number)object).floatValue();
-      } else {
-         try {
-            return Float.parseFloat(object.toString());
-         } catch (Exception var4) {
-            throw wrongValueFormatException(index, "float", object, var4);
-         }
-      }
-   }
-
-   public Number getNumber(int index) throws JSONException {
-      Object object = this.get(index);
-
-      try {
-         return object instanceof Number ? (Number)object : JSONObject.stringToNumber(object.toString());
-      } catch (Exception var4) {
-         throw wrongValueFormatException(index, "number", object, var4);
-      }
-   }
-
-   public <E extends Enum<E>> E getEnum(Class<E> clazz, int index) throws JSONException {
-      E val = this.optEnum(clazz, index);
-      if (val == null) {
-         throw wrongValueFormatException(index, "enum of type " + JSONObject.quote(clazz.getSimpleName()), this.opt(index), null);
-      } else {
-         return val;
-      }
-   }
-
-   public BigDecimal getBigDecimal(int index) throws JSONException {
-      Object object = this.get(index);
-      BigDecimal val = JSONObject.objectToBigDecimal(object, null);
-      if (val == null) {
-         throw wrongValueFormatException(index, "BigDecimal", object, null);
-      } else {
-         return val;
-      }
-   }
-
-   public BigInteger getBigInteger(int index) throws JSONException {
-      Object object = this.get(index);
-      BigInteger val = JSONObject.objectToBigInteger(object, null);
-      if (val == null) {
-         throw wrongValueFormatException(index, "BigInteger", object, null);
-      } else {
-         return val;
-      }
-   }
-
-   public int getInt(int index) throws JSONException {
-      Object object = this.get(index);
-      if (object instanceof Number) {
-         return ((Number)object).intValue();
-      } else {
-         try {
-            return Integer.parseInt(object.toString());
-         } catch (Exception var4) {
-            throw wrongValueFormatException(index, "int", object, var4);
-         }
-      }
-   }
-
-   public JSONArray getJSONArray(int index) throws JSONException {
-      Object object = this.get(index);
-      if (object instanceof JSONArray) {
-         return (JSONArray)object;
-      } else {
-         throw wrongValueFormatException(index, "JSONArray", object, null);
-      }
-   }
-
-   public JSONObject getJSONObject(int index) throws JSONException {
-      Object object = this.get(index);
-      if (object instanceof JSONObject) {
-         return (JSONObject)object;
-      } else {
-         throw wrongValueFormatException(index, "JSONObject", object, null);
-      }
-   }
-
-   public long getLong(int index) throws JSONException {
-      Object object = this.get(index);
-      if (object instanceof Number) {
-         return ((Number)object).longValue();
-      } else {
-         try {
-            return Long.parseLong(object.toString());
-         } catch (Exception var4) {
-            throw wrongValueFormatException(index, "long", object, var4);
-         }
-      }
-   }
-
-   public String getString(int index) throws JSONException {
-      Object object = this.get(index);
-      if (object instanceof String) {
-         return (String)object;
-      } else {
-         throw wrongValueFormatException(index, "String", object, null);
-      }
-   }
-
-   public boolean isNull(int index) {
-      return JSONObject.NULL.equals(this.opt(index));
-   }
-
-   public String join(String separator) throws JSONException {
-      int len = this.length();
-      if (len == 0) {
-         return "";
-      } else {
-         StringBuilder sb = new StringBuilder(JSONObject.valueToString(this.myArrayList.get(0)));
-
-         for (int i = 1; i < len; i++) {
-            sb.append(separator).append(JSONObject.valueToString(this.myArrayList.get(i)));
-         }
-
-         return sb.toString();
-      }
-   }
-
-   public int length() {
-      return this.myArrayList.size();
-   }
-
-   public void clear() {
-      this.myArrayList.clear();
-   }
-
-   public Object opt(int index) {
-      return index >= 0 && index < this.length() ? this.myArrayList.get(index) : null;
-   }
-
-   public boolean optBoolean(int index) {
-      return this.optBoolean(index, false);
-   }
-
-   public boolean optBoolean(int index, boolean defaultValue) {
-      try {
-         return this.getBoolean(index);
-      } catch (Exception var4) {
-         return defaultValue;
-      }
-   }
-
-   public Boolean optBooleanObject(int index) {
-      return this.optBooleanObject(index, false);
-   }
-
-   public Boolean optBooleanObject(int index, Boolean defaultValue) {
-      try {
-         return this.getBoolean(index);
-      } catch (Exception var4) {
-         return defaultValue;
-      }
-   }
-
-   public double optDouble(int index) {
-      return this.optDouble(index, Double.NaN);
-   }
-
-   public double optDouble(int index, double defaultValue) {
-      Number val = this.optNumber(index, null);
-      return val == null ? defaultValue : val.doubleValue();
-   }
-
-   public Double optDoubleObject(int index) {
-      return this.optDoubleObject(index, Double.NaN);
-   }
-
-   public Double optDoubleObject(int index, Double defaultValue) {
-      Number val = this.optNumber(index, null);
-      return val == null ? defaultValue : val.doubleValue();
-   }
-
-   public float optFloat(int index) {
-      return this.optFloat(index, Float.NaN);
-   }
-
-   public float optFloat(int index, float defaultValue) {
-      Number val = this.optNumber(index, null);
-      return val == null ? defaultValue : val.floatValue();
-   }
-
-   public Float optFloatObject(int index) {
-      return this.optFloatObject(index, Float.NaN);
-   }
-
-   public Float optFloatObject(int index, Float defaultValue) {
-      Number val = this.optNumber(index, null);
-      return val == null ? defaultValue : val.floatValue();
-   }
-
-   public int optInt(int index) {
-      return this.optInt(index, 0);
-   }
-
-   public int optInt(int index, int defaultValue) {
-      Number val = this.optNumber(index, null);
-      return val == null ? defaultValue : val.intValue();
-   }
-
-   public Integer optIntegerObject(int index) {
-      return this.optIntegerObject(index, 0);
-   }
-
-   public Integer optIntegerObject(int index, Integer defaultValue) {
-      Number val = this.optNumber(index, null);
-      return val == null ? defaultValue : val.intValue();
-   }
-
-   public <E extends Enum<E>> E optEnum(Class<E> clazz, int index) {
-      return this.optEnum(clazz, index, null);
-   }
-
-   public <E extends Enum<E>> E optEnum(Class<E> clazz, int index, E defaultValue) {
-      try {
-         Object val = this.opt(index);
-         if (JSONObject.NULL.equals(val)) {
-            return defaultValue;
-         } else {
-            return (E)(clazz.isAssignableFrom(val.getClass()) ? val : Enum.valueOf(clazz, val.toString()));
-         }
-      } catch (IllegalArgumentException var6) {
-         return defaultValue;
-      } catch (NullPointerException var7) {
-         return defaultValue;
-      }
-   }
-
-   public BigInteger optBigInteger(int index, BigInteger defaultValue) {
-      Object val = this.opt(index);
-      return JSONObject.objectToBigInteger(val, defaultValue);
-   }
-
-   public BigDecimal optBigDecimal(int index, BigDecimal defaultValue) {
-      Object val = this.opt(index);
-      return JSONObject.objectToBigDecimal(val, defaultValue);
-   }
-
-   public JSONArray optJSONArray(int index) {
-      return this.optJSONArray(index, null);
-   }
-
-   public JSONArray optJSONArray(int index, JSONArray defaultValue) {
-      Object object = this.opt(index);
-      return object instanceof JSONArray ? (JSONArray)object : defaultValue;
-   }
-
-   public JSONObject optJSONObject(int index) {
-      return this.optJSONObject(index, null);
-   }
-
-   public JSONObject optJSONObject(int index, JSONObject defaultValue) {
-      Object object = this.opt(index);
-      return object instanceof JSONObject ? (JSONObject)object : defaultValue;
-   }
-
-   public long optLong(int index) {
-      return this.optLong(index, 0L);
-   }
-
-   public long optLong(int index, long defaultValue) {
-      Number val = this.optNumber(index, null);
-      return val == null ? defaultValue : val.longValue();
-   }
-
-   public Long optLongObject(int index) {
-      return this.optLongObject(index, 0L);
-   }
-
-   public Long optLongObject(int index, Long defaultValue) {
-      Number val = this.optNumber(index, null);
-      return val == null ? defaultValue : val.longValue();
-   }
-
-   public Number optNumber(int index) {
-      return this.optNumber(index, null);
-   }
-
-   public Number optNumber(int index, Number defaultValue) {
-      Object val = this.opt(index);
-      if (JSONObject.NULL.equals(val)) {
-         return defaultValue;
-      } else if (val instanceof Number) {
-         return (Number)val;
-      } else if (val instanceof String) {
-         try {
-            return JSONObject.stringToNumber((String)val);
-         } catch (Exception var5) {
-            return defaultValue;
-         }
-      } else {
-         return defaultValue;
-      }
-   }
-
-   public String optString(int index) {
-      return this.optString(index, "");
-   }
-
-   public String optString(int index, String defaultValue) {
-      Object object = this.opt(index);
-      return JSONObject.NULL.equals(object) ? defaultValue : object.toString();
-   }
-
-   public JSONArray put(boolean value) {
-      return this.put(value ? Boolean.TRUE : Boolean.FALSE);
-   }
-
-   public JSONArray put(Collection<?> value) {
-      return this.put(new JSONArray(value));
-   }
-
-   public JSONArray put(double value) throws JSONException {
-      return this.put(Double.valueOf(value));
-   }
-
-   public JSONArray put(float value) throws JSONException {
-      return this.put(Float.valueOf(value));
-   }
-
-   public JSONArray put(int value) {
-      return this.put(Integer.valueOf(value));
-   }
-
-   public JSONArray put(long value) {
-      return this.put(Long.valueOf(value));
-   }
-
-   public JSONArray put(Map<?, ?> value) {
-      return this.put(new JSONObject(value));
-   }
-
-   public JSONArray put(Object value) {
-      JSONObject.testValidity(value);
-      this.myArrayList.add(value);
-      return this;
-   }
-
-   public JSONArray put(int index, boolean value) throws JSONException {
-      return this.put(index, value ? Boolean.TRUE : Boolean.FALSE);
-   }
-
-   public JSONArray put(int index, Collection<?> value) throws JSONException {
-      return this.put(index, new JSONArray(value));
-   }
-
-   public JSONArray put(int index, double value) throws JSONException {
-      return this.put(index, Double.valueOf(value));
-   }
-
-   public JSONArray put(int index, float value) throws JSONException {
-      return this.put(index, Float.valueOf(value));
-   }
-
-   public JSONArray put(int index, int value) throws JSONException {
-      return this.put(index, Integer.valueOf(value));
-   }
-
-   public JSONArray put(int index, long value) throws JSONException {
-      return this.put(index, Long.valueOf(value));
-   }
-
-   public JSONArray put(int index, Map<?, ?> value) throws JSONException {
-      this.put(index, new JSONObject(value, new JSONParserConfiguration()));
-      return this;
-   }
-
-   public JSONArray put(int index, Map<?, ?> value, JSONParserConfiguration jsonParserConfiguration) throws JSONException {
-      this.put(index, new JSONObject(value, jsonParserConfiguration));
-      return this;
-   }
-
-   public JSONArray put(int index, Object value) throws JSONException {
-      if (index < 0) {
-         throw new JSONException("JSONArray[" + index + "] not found.");
-      } else if (index < this.length()) {
-         JSONObject.testValidity(value);
-         this.myArrayList.set(index, value);
-         return this;
-      } else if (index == this.length()) {
-         return this.put(value);
-      } else {
-         this.myArrayList.ensureCapacity(index + 1);
-
-         while (index != this.length()) {
-            this.myArrayList.add(JSONObject.NULL);
-         }
-
-         return this.put(value);
-      }
-   }
-
-   public JSONArray putAll(Collection<?> collection) {
-      this.addAll(collection, false);
-      return this;
-   }
-
-   public JSONArray putAll(Iterable<?> iter) {
-      this.addAll(iter, false);
-      return this;
-   }
-
-   public JSONArray putAll(JSONArray array) {
-      this.myArrayList.addAll(array.myArrayList);
-      return this;
-   }
-
-   public JSONArray putAll(Object array) throws JSONException {
-      this.addAll(array, false);
-      return this;
-   }
-
-   public Object query(String jsonPointer) {
-      return this.query(new JSONPointer(jsonPointer));
-   }
-
-   public Object query(JSONPointer jsonPointer) {
-      return jsonPointer.queryFrom(this);
-   }
-
-   public Object optQuery(String jsonPointer) {
-      return this.optQuery(new JSONPointer(jsonPointer));
-   }
-
-   public Object optQuery(JSONPointer jsonPointer) {
-      try {
-         return jsonPointer.queryFrom(this);
-      } catch (JSONPointerException var3) {
-         return null;
-      }
-   }
-
-   public Object remove(int index) {
-      return index >= 0 && index < this.length() ? this.myArrayList.remove(index) : null;
-   }
-
-   public boolean similar(Object other) {
-      if (!(other instanceof JSONArray)) {
-         return false;
-      } else {
-         int len = this.length();
-         if (len != ((JSONArray)other).length()) {
-            return false;
-         } else {
-            for (int i = 0; i < len; i++) {
-               Object valueThis = this.myArrayList.get(i);
-               Object valueOther = ((JSONArray)other).myArrayList.get(i);
-               if (valueThis != valueOther) {
-                  if (valueThis == null) {
-                     return false;
-                  }
-
-                  if (valueThis instanceof JSONObject) {
-                     if (!((JSONObject)valueThis).similar(valueOther)) {
-                        return false;
-                     }
-                  } else if (valueThis instanceof JSONArray) {
-                     if (!((JSONArray)valueThis).similar(valueOther)) {
-                        return false;
-                     }
-                  } else if (valueThis instanceof Number && valueOther instanceof Number) {
-                     if (!JSONObject.isNumberSimilar((Number)valueThis, (Number)valueOther)) {
-                        return false;
-                     }
-                  } else if (valueThis instanceof JSONString && valueOther instanceof JSONString) {
-                     if (!((JSONString)valueThis).toJSONString().equals(((JSONString)valueOther).toJSONString())) {
-                        return false;
-                     }
-                  } else if (!valueThis.equals(valueOther)) {
-                     return false;
-                  }
-               }
-            }
-
-            return true;
-         }
-      }
-   }
-
-   public JSONObject toJSONObject(JSONArray names) throws JSONException {
-      if (names != null && !names.isEmpty() && !this.isEmpty()) {
-         JSONObject jo = new JSONObject(names.length());
-
-         for (int i = 0; i < names.length(); i++) {
-            jo.put(names.getString(i), this.opt(i));
-         }
-
-         return jo;
-      } else {
-         return null;
-      }
-   }
-
-   @Override
-   public String toString() {
-      try {
-         return this.toString(0);
-      } catch (Exception var2) {
-         return null;
-      }
-   }
-
-   public String toString(int indentFactor) throws JSONException {
-      int initialSize = this.myArrayList.size() * 2;
-      Writer sw = new StringBuilderWriter(Math.max(initialSize, 16));
-      return this.write(sw, indentFactor, 0).toString();
-   }
-
-   public Writer write(Writer writer) throws JSONException {
-      return this.write(writer, 0, 0);
-   }
-
-   public Writer write(Writer writer, int indentFactor, int indent) throws JSONException {
-      try {
-         boolean needsComma = false;
-         int length = this.length();
-         writer.write(91);
-         if (length == 1) {
-            try {
-               JSONObject.writeValue(writer, this.myArrayList.get(0), indentFactor, indent);
-            } catch (Exception var10) {
-               throw new JSONException("Unable to write JSONArray value at index: 0", var10);
-            }
-         } else if (length != 0) {
-            int newIndent = indent + indentFactor;
-
-            for (int i = 0; i < length; i++) {
-               if (needsComma) {
-                  writer.write(44);
-               }
-
-               if (indentFactor > 0) {
-                  writer.write(10);
-               }
-
-               JSONObject.indent(writer, newIndent);
-
-               try {
-                  JSONObject.writeValue(writer, this.myArrayList.get(i), indentFactor, newIndent);
-               } catch (Exception var9) {
-                  throw new JSONException("Unable to write JSONArray value at index: " + i, var9);
-               }
-
-               needsComma = true;
-            }
-
-            if (indentFactor > 0) {
-               writer.write(10);
-            }
-
-            JSONObject.indent(writer, indent);
-         }
-
-         writer.write(93);
-         return writer;
-      } catch (IOException var11) {
-         throw new JSONException(var11);
-      }
-   }
-
-   public List<Object> toList() {
-      List<Object> results = new ArrayList<>(this.myArrayList.size());
-
-      for (Object element : this.myArrayList) {
-         if (element == null || JSONObject.NULL.equals(element)) {
-            results.add(null);
-         } else if (element instanceof JSONArray) {
-            results.add(((JSONArray)element).toList());
-         } else if (element instanceof JSONObject) {
-            results.add(((JSONObject)element).toMap());
-         } else {
-            results.add(element);
-         }
-      }
-
-      return results;
-   }
-
-   public boolean isEmpty() {
-      return this.myArrayList.isEmpty();
-   }
-
-   private void addAll(Collection<?> collection, boolean wrap, int recursionDepth, JSONParserConfiguration jsonParserConfiguration) {
-      this.myArrayList.ensureCapacity(this.myArrayList.size() + collection.size());
-      if (wrap) {
-         for (Object o : collection) {
-            this.put(JSONObject.wrap(o, recursionDepth + 1, jsonParserConfiguration));
-         }
-      } else {
-         for (Object o : collection) {
-            this.put(o);
-         }
-      }
-   }
-
-   private void addAll(Iterable<?> iter, boolean wrap) {
-      if (wrap) {
-         for (Object o : iter) {
-            this.put(JSONObject.wrap(o));
-         }
-      } else {
-         for (Object o : iter) {
-            this.put(o);
-         }
-      }
-   }
-
-   private void addAll(Object array, boolean wrap) throws JSONException {
-      this.addAll(array, wrap, 0);
-   }
-
-   private void addAll(Object array, boolean wrap, int recursionDepth) {
-      this.addAll(array, wrap, recursionDepth, new JSONParserConfiguration());
-   }
-
-   private void addAll(Object array, boolean wrap, int recursionDepth, JSONParserConfiguration jsonParserConfiguration) throws JSONException {
-      if (array.getClass().isArray()) {
-         int length = Array.getLength(array);
-         this.myArrayList.ensureCapacity(this.myArrayList.size() + length);
-         if (wrap) {
-            for (int i = 0; i < length; i++) {
-               this.put(JSONObject.wrap(Array.get(array, i), recursionDepth + 1, jsonParserConfiguration));
-            }
-         } else {
-            for (int i = 0; i < length; i++) {
-               this.put(Array.get(array, i));
-            }
-         }
-      } else if (array instanceof JSONArray) {
-         this.myArrayList.addAll(((JSONArray)array).myArrayList);
-      } else if (array instanceof Collection) {
-         this.addAll((Collection<?>)array, wrap, recursionDepth, jsonParserConfiguration);
-      } else {
-         if (!(array instanceof Iterable)) {
-            throw new JSONException("JSONArray initial value should be a string or collection or array.");
-         }
-
-         this.addAll((Iterable<?>)array, wrap);
-      }
-   }
-
-   private static JSONException wrongValueFormatException(int idx, String valueType, Object value, Throwable cause) {
-      if (value == null) {
-         return new JSONException("JSONArray[" + idx + "] is not a " + valueType + " (null).", cause);
-      } else {
-         return !(value instanceof Map) && !(value instanceof Iterable) && !(value instanceof JSONObject)
-            ? new JSONException("JSONArray[" + idx + "] is not a " + valueType + " (" + value.getClass() + " : " + value + ").", cause)
-            : new JSONException("JSONArray[" + idx + "] is not a " + valueType + " (" + value.getClass() + ").", cause);
-      }
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/JSONException.java b/dev/hexedhero/hivechecker/shaded/json/JSONException.java
deleted file mode 100644
index dc9a2fd..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/JSONException.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-public class JSONException extends RuntimeException {
-   private static final long serialVersionUID = 0L;
-
-   public JSONException(String message) {
-      super(message);
-   }
-
-   public JSONException(String message, Throwable cause) {
-      super(message, cause);
-   }
-
-   public JSONException(Throwable cause) {
-      super(cause.getMessage(), cause);
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/JSONObject.java b/dev/hexedhero/hivechecker/shaded/json/JSONObject.java
deleted file mode 100644
index 6429275..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/JSONObject.java
+++ /dev/null
@@ -1,1503 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.Writer;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import java.util.Locale;
-import java.util.Map;
-import java.util.ResourceBundle;
-import java.util.Set;
-import java.util.Map.Entry;
-import java.util.regex.Pattern;
-
-public class JSONObject {
-   static final Pattern NUMBER_PATTERN = Pattern.compile("-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?");
-   private final Map<String, Object> map;
-   public static final Object NULL = new JSONObject.Null();
-
-   public Class<? extends Map> getMapType() {
-      return (Class<? extends Map>)this.map.getClass();
-   }
-
-   public JSONObject() {
-      this.map = new HashMap<>();
-   }
-
-   public JSONObject(JSONObject jo, String... names) {
-      this(names.length);
-
-      for (int i = 0; i < names.length; i++) {
-         try {
-            this.putOnce(names[i], jo.opt(names[i]));
-         } catch (Exception var5) {
-         }
-      }
-   }
-
-   public JSONObject(JSONTokener x) throws JSONException {
-      this(x, x.getJsonParserConfiguration());
-   }
-
-   public JSONObject(JSONTokener x, JSONParserConfiguration jsonParserConfiguration) throws JSONException {
-      this();
-      boolean isInitial = x.getPrevious() == 0;
-      if (x.nextClean() != '{') {
-         throw x.syntaxError("A JSONObject text must begin with '{'");
-      } else {
-         while (true) {
-            char c = x.nextClean();
-            switch (c) {
-               case '\u0000':
-                  throw x.syntaxError("A JSONObject text must end with '}'");
-               case '}':
-                  if (isInitial && jsonParserConfiguration.isStrictMode() && x.nextClean() != 0) {
-                     throw x.syntaxError("Strict mode error: Unparsed characters found at end of input text");
-                  }
-
-                  return;
-            }
-
-            String key = x.nextSimpleValue(c).toString();
-            c = x.nextClean();
-            if (c != ':') {
-               throw x.syntaxError("Expected a ':' after a key");
-            }
-
-            if (key != null) {
-               boolean keyExists = this.opt(key) != null;
-               if (keyExists && !jsonParserConfiguration.isOverwriteDuplicateKey()) {
-                  throw x.syntaxError("Duplicate key \"" + key + "\"");
-               }
-
-               Object value = x.nextValue();
-               if (value != null) {
-                  this.put(key, value);
-               }
-            }
-
-            switch (x.nextClean()) {
-               case ';':
-                  if (jsonParserConfiguration.isStrictMode()) {
-                     throw x.syntaxError("Strict mode error: Invalid character ';' found");
-                  }
-               case ',':
-                  if (x.nextClean() == '}') {
-                     if (jsonParserConfiguration.isStrictMode()) {
-                        throw x.syntaxError("Strict mode error: Expected another object element");
-                     }
-
-                     return;
-                  }
-
-                  if (x.end()) {
-                     throw x.syntaxError("A JSONObject text must end with '}'");
-                  }
-
-                  x.back();
-                  break;
-               case '}':
-                  if (isInitial && jsonParserConfiguration.isStrictMode() && x.nextClean() != 0) {
-                     throw x.syntaxError("Strict mode error: Unparsed characters found at end of input text");
-                  }
-
-                  return;
-               default:
-                  throw x.syntaxError("Expected a ',' or '}'");
-            }
-         }
-      }
-   }
-
-   public JSONObject(Map<?, ?> m) {
-      this(m, 0, new JSONParserConfiguration());
-   }
-
-   public JSONObject(Map<?, ?> m, JSONParserConfiguration jsonParserConfiguration) {
-      this(m, 0, jsonParserConfiguration);
-   }
-
-   private JSONObject(Map<?, ?> m, int recursionDepth, JSONParserConfiguration jsonParserConfiguration) {
-      if (recursionDepth > jsonParserConfiguration.getMaxNestingDepth()) {
-         throw new JSONException("JSONObject has reached recursion depth limit of " + jsonParserConfiguration.getMaxNestingDepth());
-      } else {
-         if (m == null) {
-            this.map = new HashMap<>();
-         } else {
-            this.map = new HashMap<>(m.size());
-
-            for (Entry<?, ?> e : m.entrySet()) {
-               if (e.getKey() == null) {
-                  throw new NullPointerException("Null key.");
-               }
-
-               Object value = e.getValue();
-               if (value != null || jsonParserConfiguration.isUseNativeNulls()) {
-                  testValidity(value);
-                  this.map.put(String.valueOf(e.getKey()), wrap(value, recursionDepth + 1, jsonParserConfiguration));
-               }
-            }
-         }
-      }
-   }
-
-   public JSONObject(Object bean) {
-      this();
-      this.populateMap(bean);
-   }
-
-   private JSONObject(Object bean, Set<Object> objectsRecord) {
-      this();
-      this.populateMap(bean, objectsRecord);
-   }
-
-   public JSONObject(Object object, String... names) {
-      this(names.length);
-      Class<?> c = object.getClass();
-
-      for (int i = 0; i < names.length; i++) {
-         String name = names[i];
-
-         try {
-            this.putOpt(name, c.getField(name).get(object));
-         } catch (Exception var7) {
-         }
-      }
-   }
-
-   public JSONObject(String source) throws JSONException {
-      this(source, new JSONParserConfiguration());
-   }
-
-   public JSONObject(String source, JSONParserConfiguration jsonParserConfiguration) throws JSONException {
-      this(new JSONTokener(source, jsonParserConfiguration), jsonParserConfiguration);
-   }
-
-   public JSONObject(String baseName, Locale locale) throws JSONException {
-      this();
-      ResourceBundle bundle = ResourceBundle.getBundle(baseName, locale, Thread.currentThread().getContextClassLoader());
-      Enumeration<String> keys = bundle.getKeys();
-
-      while (keys.hasMoreElements()) {
-         Object key = keys.nextElement();
-         if (key != null) {
-            String[] path = ((String)key).split("\\.");
-            int last = path.length - 1;
-            JSONObject target = this;
-
-            for (int i = 0; i < last; i++) {
-               String segment = path[i];
-               JSONObject nextTarget = target.optJSONObject(segment);
-               if (nextTarget == null) {
-                  nextTarget = new JSONObject();
-                  target.put(segment, nextTarget);
-               }
-
-               target = nextTarget;
-            }
-
-            target.put(path[last], bundle.getString((String)key));
-         }
-      }
-   }
-
-   protected JSONObject(int initialCapacity) {
-      this.map = new HashMap<>(initialCapacity);
-   }
-
-   public JSONObject accumulate(String key, Object value) throws JSONException {
-      testValidity(value);
-      Object object = this.opt(key);
-      if (object == null) {
-         this.put(key, value instanceof JSONArray ? new JSONArray().put(value) : value);
-      } else if (object instanceof JSONArray) {
-         ((JSONArray)object).put(value);
-      } else {
-         this.put(key, new JSONArray().put(object).put(value));
-      }
-
-      return this;
-   }
-
-   public JSONObject append(String key, Object value) throws JSONException {
-      testValidity(value);
-      Object object = this.opt(key);
-      if (object == null) {
-         this.put(key, new JSONArray().put(value));
-      } else {
-         if (!(object instanceof JSONArray)) {
-            throw wrongValueFormatException(key, "JSONArray", null, null);
-         }
-
-         this.put(key, ((JSONArray)object).put(value));
-      }
-
-      return this;
-   }
-
-   public static String doubleToString(double d) {
-      if (!Double.isInfinite(d) && !Double.isNaN(d)) {
-         String string = Double.toString(d);
-         if (string.indexOf(46) > 0 && string.indexOf(101) < 0 && string.indexOf(69) < 0) {
-            while (string.endsWith("0")) {
-               string = string.substring(0, string.length() - 1);
-            }
-
-            if (string.endsWith(".")) {
-               string = string.substring(0, string.length() - 1);
-            }
-         }
-
-         return string;
-      } else {
-         return "null";
-      }
-   }
-
-   public Object get(String key) throws JSONException {
-      if (key == null) {
-         throw new JSONException("Null key.");
-      } else {
-         Object object = this.opt(key);
-         if (object == null) {
-            throw new JSONException("JSONObject[" + quote(key) + "] not found.");
-         } else {
-            return object;
-         }
-      }
-   }
-
-   public <E extends Enum<E>> E getEnum(Class<E> clazz, String key) throws JSONException {
-      E val = this.optEnum(clazz, key);
-      if (val == null) {
-         throw wrongValueFormatException(key, "enum of type " + quote(clazz.getSimpleName()), this.opt(key), null);
-      } else {
-         return val;
-      }
-   }
-
-   public boolean getBoolean(String key) throws JSONException {
-      Object object = this.get(key);
-      if (!object.equals(Boolean.FALSE) && (!(object instanceof String) || !((String)object).equalsIgnoreCase("false"))) {
-         if (!object.equals(Boolean.TRUE) && (!(object instanceof String) || !((String)object).equalsIgnoreCase("true"))) {
-            throw wrongValueFormatException(key, "Boolean", object, null);
-         } else {
-            return true;
-         }
-      } else {
-         return false;
-      }
-   }
-
-   public BigInteger getBigInteger(String key) throws JSONException {
-      Object object = this.get(key);
-      BigInteger ret = objectToBigInteger(object, null);
-      if (ret != null) {
-         return ret;
-      } else {
-         throw wrongValueFormatException(key, "BigInteger", object, null);
-      }
-   }
-
-   public BigDecimal getBigDecimal(String key) throws JSONException {
-      Object object = this.get(key);
-      BigDecimal ret = objectToBigDecimal(object, null);
-      if (ret != null) {
-         return ret;
-      } else {
-         throw wrongValueFormatException(key, "BigDecimal", object, null);
-      }
-   }
-
-   public double getDouble(String key) throws JSONException {
-      Object object = this.get(key);
-      if (object instanceof Number) {
-         return ((Number)object).doubleValue();
-      } else {
-         try {
-            return Double.parseDouble(object.toString());
-         } catch (Exception var4) {
-            throw wrongValueFormatException(key, "double", object, var4);
-         }
-      }
-   }
-
-   public float getFloat(String key) throws JSONException {
-      Object object = this.get(key);
-      if (object instanceof Number) {
-         return ((Number)object).floatValue();
-      } else {
-         try {
-            return Float.parseFloat(object.toString());
-         } catch (Exception var4) {
-            throw wrongValueFormatException(key, "float", object, var4);
-         }
-      }
-   }
-
-   public Number getNumber(String key) throws JSONException {
-      Object object = this.get(key);
-
-      try {
-         return object instanceof Number ? (Number)object : stringToNumber(object.toString());
-      } catch (Exception var4) {
-         throw wrongValueFormatException(key, "number", object, var4);
-      }
-   }
-
-   public int getInt(String key) throws JSONException {
-      Object object = this.get(key);
-      if (object instanceof Number) {
-         return ((Number)object).intValue();
-      } else {
-         try {
-            return Integer.parseInt(object.toString());
-         } catch (Exception var4) {
-            throw wrongValueFormatException(key, "int", object, var4);
-         }
-      }
-   }
-
-   public JSONArray getJSONArray(String key) throws JSONException {
-      Object object = this.get(key);
-      if (object instanceof JSONArray) {
-         return (JSONArray)object;
-      } else {
-         throw wrongValueFormatException(key, "JSONArray", object, null);
-      }
-   }
-
-   public JSONObject getJSONObject(String key) throws JSONException {
-      Object object = this.get(key);
-      if (object instanceof JSONObject) {
-         return (JSONObject)object;
-      } else {
-         throw wrongValueFormatException(key, "JSONObject", object, null);
-      }
-   }
-
-   public long getLong(String key) throws JSONException {
-      Object object = this.get(key);
-      if (object instanceof Number) {
-         return ((Number)object).longValue();
-      } else {
-         try {
-            return Long.parseLong(object.toString());
-         } catch (Exception var4) {
-            throw wrongValueFormatException(key, "long", object, var4);
-         }
-      }
-   }
-
-   public static String[] getNames(JSONObject jo) {
-      return jo.isEmpty() ? null : jo.keySet().toArray(new String[jo.length()]);
-   }
-
-   public static String[] getNames(Object object) {
-      if (object == null) {
-         return null;
-      } else {
-         Class<?> klass = object.getClass();
-         Field[] fields = klass.getFields();
-         int length = fields.length;
-         if (length == 0) {
-            return null;
-         } else {
-            String[] names = new String[length];
-
-            for (int i = 0; i < length; i++) {
-               names[i] = fields[i].getName();
-            }
-
-            return names;
-         }
-      }
-   }
-
-   public String getString(String key) throws JSONException {
-      Object object = this.get(key);
-      if (object instanceof String) {
-         return (String)object;
-      } else {
-         throw wrongValueFormatException(key, "string", object, null);
-      }
-   }
-
-   public boolean has(String key) {
-      return this.map.containsKey(key);
-   }
-
-   public JSONObject increment(String key) throws JSONException {
-      Object value = this.opt(key);
-      if (value == null) {
-         this.put(key, 1);
-      } else if (value instanceof Integer) {
-         this.put(key, (Integer)value + 1);
-      } else if (value instanceof Long) {
-         this.put(key, (Long)value + 1L);
-      } else if (value instanceof BigInteger) {
-         this.put(key, ((BigInteger)value).add(BigInteger.ONE));
-      } else if (value instanceof Float) {
-         this.put(key, (Float)value + 1.0F);
-      } else if (value instanceof Double) {
-         this.put(key, (Double)value + 1.0);
-      } else {
-         if (!(value instanceof BigDecimal)) {
-            throw new JSONException("Unable to increment [" + quote(key) + "].");
-         }
-
-         this.put(key, ((BigDecimal)value).add(BigDecimal.ONE));
-      }
-
-      return this;
-   }
-
-   public boolean isNull(String key) {
-      return NULL.equals(this.opt(key));
-   }
-
-   public Iterator<String> keys() {
-      return this.keySet().iterator();
-   }
-
-   public Set<String> keySet() {
-      return this.map.keySet();
-   }
-
-   protected Set<Entry<String, Object>> entrySet() {
-      return this.map.entrySet();
-   }
-
-   public int length() {
-      return this.map.size();
-   }
-
-   public void clear() {
-      this.map.clear();
-   }
-
-   public boolean isEmpty() {
-      return this.map.isEmpty();
-   }
-
-   public JSONArray names() {
-      return this.map.isEmpty() ? null : new JSONArray(this.map.keySet());
-   }
-
-   public static String numberToString(Number number) throws JSONException {
-      if (number == null) {
-         throw new JSONException("Null pointer");
-      } else {
-         testValidity(number);
-         String string = number.toString();
-         if (string.indexOf(46) > 0 && string.indexOf(101) < 0 && string.indexOf(69) < 0) {
-            while (string.endsWith("0")) {
-               string = string.substring(0, string.length() - 1);
-            }
-
-            if (string.endsWith(".")) {
-               string = string.substring(0, string.length() - 1);
-            }
-         }
-
-         return string;
-      }
-   }
-
-   public Object opt(String key) {
-      return key == null ? null : this.map.get(key);
-   }
-
-   public <E extends Enum<E>> E optEnum(Class<E> clazz, String key) {
-      return this.optEnum(clazz, key, null);
-   }
-
-   public <E extends Enum<E>> E optEnum(Class<E> clazz, String key, E defaultValue) {
-      try {
-         Object val = this.opt(key);
-         if (NULL.equals(val)) {
-            return defaultValue;
-         } else {
-            return (E)(clazz.isAssignableFrom(val.getClass()) ? val : Enum.valueOf(clazz, val.toString()));
-         }
-      } catch (IllegalArgumentException var6) {
-         return defaultValue;
-      } catch (NullPointerException var7) {
-         return defaultValue;
-      }
-   }
-
-   public boolean optBoolean(String key) {
-      return this.optBoolean(key, false);
-   }
-
-   public boolean optBoolean(String key, boolean defaultValue) {
-      Object val = this.opt(key);
-      if (NULL.equals(val)) {
-         return defaultValue;
-      } else if (val instanceof Boolean) {
-         return (Boolean)val;
-      } else {
-         try {
-            return this.getBoolean(key);
-         } catch (Exception var5) {
-            return defaultValue;
-         }
-      }
-   }
-
-   public Boolean optBooleanObject(String key) {
-      return this.optBooleanObject(key, false);
-   }
-
-   public Boolean optBooleanObject(String key, Boolean defaultValue) {
-      Object val = this.opt(key);
-      if (NULL.equals(val)) {
-         return defaultValue;
-      } else if (val instanceof Boolean) {
-         return (Boolean)val;
-      } else {
-         try {
-            return this.getBoolean(key);
-         } catch (Exception var5) {
-            return defaultValue;
-         }
-      }
-   }
-
-   public BigDecimal optBigDecimal(String key, BigDecimal defaultValue) {
-      Object val = this.opt(key);
-      return objectToBigDecimal(val, defaultValue);
-   }
-
-   static BigDecimal objectToBigDecimal(Object val, BigDecimal defaultValue) {
-      return objectToBigDecimal(val, defaultValue, true);
-   }
-
-   static BigDecimal objectToBigDecimal(Object val, BigDecimal defaultValue, boolean exact) {
-      if (NULL.equals(val)) {
-         return defaultValue;
-      } else if (val instanceof BigDecimal) {
-         return (BigDecimal)val;
-      } else if (val instanceof BigInteger) {
-         return new BigDecimal((BigInteger)val);
-      } else if (!(val instanceof Double) && !(val instanceof Float)) {
-         if (!(val instanceof Long) && !(val instanceof Integer) && !(val instanceof Short) && !(val instanceof Byte)) {
-            try {
-               return new BigDecimal(val.toString());
-            } catch (Exception var4) {
-               return defaultValue;
-            }
-         } else {
-            return new BigDecimal(((Number)val).longValue());
-         }
-      } else if (!numberIsFinite((Number)val)) {
-         return defaultValue;
-      } else {
-         return exact ? new BigDecimal(((Number)val).doubleValue()) : new BigDecimal(val.toString());
-      }
-   }
-
-   public BigInteger optBigInteger(String key, BigInteger defaultValue) {
-      Object val = this.opt(key);
-      return objectToBigInteger(val, defaultValue);
-   }
-
-   static BigInteger objectToBigInteger(Object val, BigInteger defaultValue) {
-      if (NULL.equals(val)) {
-         return defaultValue;
-      } else if (val instanceof BigInteger) {
-         return (BigInteger)val;
-      } else if (val instanceof BigDecimal) {
-         return ((BigDecimal)val).toBigInteger();
-      } else if (!(val instanceof Double) && !(val instanceof Float)) {
-         if (!(val instanceof Long) && !(val instanceof Integer) && !(val instanceof Short) && !(val instanceof Byte)) {
-            try {
-               String valStr = val.toString();
-               return isDecimalNotation(valStr) ? new BigDecimal(valStr).toBigInteger() : new BigInteger(valStr);
-            } catch (Exception var3) {
-               return defaultValue;
-            }
-         } else {
-            return BigInteger.valueOf(((Number)val).longValue());
-         }
-      } else {
-         return !numberIsFinite((Number)val) ? defaultValue : new BigDecimal(((Number)val).doubleValue()).toBigInteger();
-      }
-   }
-
-   public double optDouble(String key) {
-      return this.optDouble(key, Double.NaN);
-   }
-
-   public double optDouble(String key, double defaultValue) {
-      Number val = this.optNumber(key);
-      return val == null ? defaultValue : val.doubleValue();
-   }
-
-   public Double optDoubleObject(String key) {
-      return this.optDoubleObject(key, Double.NaN);
-   }
-
-   public Double optDoubleObject(String key, Double defaultValue) {
-      Number val = this.optNumber(key);
-      return val == null ? defaultValue : val.doubleValue();
-   }
-
-   public float optFloat(String key) {
-      return this.optFloat(key, Float.NaN);
-   }
-
-   public float optFloat(String key, float defaultValue) {
-      Number val = this.optNumber(key);
-      return val == null ? defaultValue : val.floatValue();
-   }
-
-   public Float optFloatObject(String key) {
-      return this.optFloatObject(key, Float.NaN);
-   }
-
-   public Float optFloatObject(String key, Float defaultValue) {
-      Number val = this.optNumber(key);
-      return val == null ? defaultValue : val.floatValue();
-   }
-
-   public int optInt(String key) {
-      return this.optInt(key, 0);
-   }
-
-   public int optInt(String key, int defaultValue) {
-      Number val = this.optNumber(key, null);
-      return val == null ? defaultValue : val.intValue();
-   }
-
-   public Integer optIntegerObject(String key) {
-      return this.optIntegerObject(key, 0);
-   }
-
-   public Integer optIntegerObject(String key, Integer defaultValue) {
-      Number val = this.optNumber(key, null);
-      return val == null ? defaultValue : val.intValue();
-   }
-
-   public JSONArray optJSONArray(String key) {
-      return this.optJSONArray(key, null);
-   }
-
-   public JSONArray optJSONArray(String key, JSONArray defaultValue) {
-      Object object = this.opt(key);
-      return object instanceof JSONArray ? (JSONArray)object : defaultValue;
-   }
-
-   public JSONObject optJSONObject(String key) {
-      return this.optJSONObject(key, null);
-   }
-
-   public JSONObject optJSONObject(String key, JSONObject defaultValue) {
-      Object object = this.opt(key);
-      return object instanceof JSONObject ? (JSONObject)object : defaultValue;
-   }
-
-   public long optLong(String key) {
-      return this.optLong(key, 0L);
-   }
-
-   public long optLong(String key, long defaultValue) {
-      Number val = this.optNumber(key, null);
-      return val == null ? defaultValue : val.longValue();
-   }
-
-   public Long optLongObject(String key) {
-      return this.optLongObject(key, 0L);
-   }
-
-   public Long optLongObject(String key, Long defaultValue) {
-      Number val = this.optNumber(key, null);
-      return val == null ? defaultValue : val.longValue();
-   }
-
-   public Number optNumber(String key) {
-      return this.optNumber(key, null);
-   }
-
-   public Number optNumber(String key, Number defaultValue) {
-      Object val = this.opt(key);
-      if (NULL.equals(val)) {
-         return defaultValue;
-      } else if (val instanceof Number) {
-         return (Number)val;
-      } else {
-         try {
-            return stringToNumber(val.toString());
-         } catch (Exception var5) {
-            return defaultValue;
-         }
-      }
-   }
-
-   public String optString(String key) {
-      return this.optString(key, "");
-   }
-
-   public String optString(String key, String defaultValue) {
-      Object object = this.opt(key);
-      return NULL.equals(object) ? defaultValue : object.toString();
-   }
-
-   private void populateMap(Object bean) {
-      this.populateMap(bean, Collections.newSetFromMap(new IdentityHashMap<>()));
-   }
-
-   private void populateMap(Object bean, Set<Object> objectsRecord) {
-      Class<?> klass = bean.getClass();
-      boolean includeSuperClass = klass.getClassLoader() != null;
-      Method[] methods = includeSuperClass ? klass.getMethods() : klass.getDeclaredMethods();
-
-      for (Method method : methods) {
-         int modifiers = method.getModifiers();
-         if (Modifier.isPublic(modifiers)
-            && !Modifier.isStatic(modifiers)
-            && method.getParameterTypes().length == 0
-            && !method.isBridge()
-            && method.getReturnType() != void.class
-            && isValidMethodName(method.getName())) {
-            String key = getKeyNameFromMethod(method);
-            if (key != null && !key.isEmpty()) {
-               try {
-                  Object result = method.invoke(bean);
-                  if (result != null) {
-                     if (objectsRecord.contains(result)) {
-                        throw recursivelyDefinedObjectException(key);
-                     }
-
-                     objectsRecord.add(result);
-                     testValidity(result);
-                     this.map.put(key, wrap(result, objectsRecord));
-                     objectsRecord.remove(result);
-                     if (result instanceof Closeable) {
-                        try {
-                           ((Closeable)result).close();
-                        } catch (IOException var14) {
-                        }
-                     }
-                  }
-               } catch (IllegalAccessException var15) {
-               } catch (IllegalArgumentException var16) {
-               } catch (InvocationTargetException var17) {
-               }
-            }
-         }
-      }
-   }
-
-   private static boolean isValidMethodName(String name) {
-      return !"getClass".equals(name) && !"getDeclaringClass".equals(name);
-   }
-
-   private static String getKeyNameFromMethod(Method method) {
-      int ignoreDepth = getAnnotationDepth(method, JSONPropertyIgnore.class);
-      if (ignoreDepth > 0) {
-         int forcedNameDepth = getAnnotationDepth(method, JSONPropertyName.class);
-         if (forcedNameDepth < 0 || ignoreDepth <= forcedNameDepth) {
-            return null;
-         }
-      }
-
-      JSONPropertyName annotation = getAnnotation(method, JSONPropertyName.class);
-      if (annotation != null && annotation.value() != null && !annotation.value().isEmpty()) {
-         return annotation.value();
-      } else {
-         String name = method.getName();
-         String key;
-         if (name.startsWith("get") && name.length() > 3) {
-            key = name.substring(3);
-         } else {
-            if (!name.startsWith("is") || name.length() <= 2) {
-               return null;
-            }
-
-            key = name.substring(2);
-         }
-
-         if (key.length() != 0 && !Character.isLowerCase(key.charAt(0))) {
-            if (key.length() == 1) {
-               key = key.toLowerCase(Locale.ROOT);
-            } else if (!Character.isUpperCase(key.charAt(1))) {
-               key = key.substring(0, 1).toLowerCase(Locale.ROOT) + key.substring(1);
-            }
-
-            return key;
-         } else {
-            return null;
-         }
-      }
-   }
-
-   private static <A extends Annotation> A getAnnotation(Method m, Class<A> annotationClass) {
-      if (m == null || annotationClass == null) {
-         return null;
-      } else if (m.isAnnotationPresent(annotationClass)) {
-         return m.getAnnotation(annotationClass);
-      } else {
-         Class<?> c = m.getDeclaringClass();
-         if (c.getSuperclass() == null) {
-            return null;
-         } else {
-            for (Class<?> i : c.getInterfaces()) {
-               try {
-                  Method im = i.getMethod(m.getName(), m.getParameterTypes());
-                  return getAnnotation(im, annotationClass);
-               } catch (SecurityException var10) {
-               } catch (NoSuchMethodException var11) {
-               }
-            }
-
-            if (c.getSuperclass().equals(Object.class)) {
-               return null;
-            } else {
-               try {
-                  return getAnnotation(c.getSuperclass().getMethod(m.getName(), m.getParameterTypes()), annotationClass);
-               } catch (SecurityException var8) {
-                  return null;
-               } catch (NoSuchMethodException var9) {
-                  return null;
-               }
-            }
-         }
-      }
-   }
-
-   private static int getAnnotationDepth(Method m, Class<? extends Annotation> annotationClass) {
-      if (m == null || annotationClass == null) {
-         return -1;
-      } else if (m.isAnnotationPresent(annotationClass)) {
-         return 1;
-      } else {
-         Class<?> c = m.getDeclaringClass();
-         if (c.getSuperclass() == null) {
-            return -1;
-         } else {
-            for (Class<?> i : c.getInterfaces()) {
-               try {
-                  Method im = i.getMethod(m.getName(), m.getParameterTypes());
-                  int d = getAnnotationDepth(im, annotationClass);
-                  if (d > 0) {
-                     return d + 1;
-                  }
-               } catch (SecurityException var11) {
-               } catch (NoSuchMethodException var12) {
-               }
-            }
-
-            if (c.getSuperclass().equals(Object.class)) {
-               return -1;
-            } else {
-               try {
-                  int d = getAnnotationDepth(c.getSuperclass().getMethod(m.getName(), m.getParameterTypes()), annotationClass);
-                  return d > 0 ? d + 1 : -1;
-               } catch (SecurityException var9) {
-                  return -1;
-               } catch (NoSuchMethodException var10) {
-                  return -1;
-               }
-            }
-         }
-      }
-   }
-
-   public JSONObject put(String key, boolean value) throws JSONException {
-      return this.put(key, value ? Boolean.TRUE : Boolean.FALSE);
-   }
-
-   public JSONObject put(String key, Collection<?> value) throws JSONException {
-      return this.put(key, new JSONArray(value));
-   }
-
-   public JSONObject put(String key, double value) throws JSONException {
-      return this.put(key, Double.valueOf(value));
-   }
-
-   public JSONObject put(String key, float value) throws JSONException {
-      return this.put(key, Float.valueOf(value));
-   }
-
-   public JSONObject put(String key, int value) throws JSONException {
-      return this.put(key, Integer.valueOf(value));
-   }
-
-   public JSONObject put(String key, long value) throws JSONException {
-      return this.put(key, Long.valueOf(value));
-   }
-
-   public JSONObject put(String key, Map<?, ?> value) throws JSONException {
-      return this.put(key, new JSONObject(value));
-   }
-
-   public JSONObject put(String key, Object value) throws JSONException {
-      if (key == null) {
-         throw new NullPointerException("Null key.");
-      } else {
-         if (value != null) {
-            testValidity(value);
-            this.map.put(key, value);
-         } else {
-            this.remove(key);
-         }
-
-         return this;
-      }
-   }
-
-   public JSONObject putOnce(String key, Object value) throws JSONException {
-      if (key == null || value == null) {
-         return this;
-      } else if (this.opt(key) != null) {
-         throw new JSONException("Duplicate key \"" + key + "\"");
-      } else {
-         return this.put(key, value);
-      }
-   }
-
-   public JSONObject putOpt(String key, Object value) throws JSONException {
-      return key != null && value != null ? this.put(key, value) : this;
-   }
-
-   public Object query(String jsonPointer) {
-      return this.query(new JSONPointer(jsonPointer));
-   }
-
-   public Object query(JSONPointer jsonPointer) {
-      return jsonPointer.queryFrom(this);
-   }
-
-   public Object optQuery(String jsonPointer) {
-      return this.optQuery(new JSONPointer(jsonPointer));
-   }
-
-   public Object optQuery(JSONPointer jsonPointer) {
-      try {
-         return jsonPointer.queryFrom(this);
-      } catch (JSONPointerException var3) {
-         return null;
-      }
-   }
-
-   public static String quote(String string) {
-      if (string != null && !string.isEmpty()) {
-         Writer sw = new StringBuilderWriter(string.length() + 2);
-
-         try {
-            return quote(string, sw).toString();
-         } catch (IOException var3) {
-            return "";
-         }
-      } else {
-         return "\"\"";
-      }
-   }
-
-   public static Writer quote(String string, Writer w) throws IOException {
-      if (string != null && !string.isEmpty()) {
-         char c = 0;
-         int len = string.length();
-         w.write(34);
-
-         for (int i = 0; i < len; i++) {
-            char b = c;
-            c = string.charAt(i);
-            switch (c) {
-               case '\b':
-                  w.write("\\b");
-                  break;
-               case '\t':
-                  w.write("\\t");
-                  break;
-               case '\n':
-                  w.write("\\n");
-                  break;
-               case '\f':
-                  w.write("\\f");
-                  break;
-               case '\r':
-                  w.write("\\r");
-                  break;
-               case '"':
-               case '\\':
-                  w.write(92);
-                  w.write(c);
-                  break;
-               case '/':
-                  if (b == '<') {
-                     w.write(92);
-                  }
-
-                  w.write(c);
-                  break;
-               default:
-                  if (c >= ' ' && (c < 128 || c >= 160) && (c < 8192 || c >= 8448)) {
-                     w.write(c);
-                  } else {
-                     w.write("\\u");
-                     String hhhh = Integer.toHexString(c);
-                     w.write("0000", 0, 4 - hhhh.length());
-                     w.write(hhhh);
-                  }
-            }
-         }
-
-         w.write(34);
-         return w;
-      } else {
-         w.write("\"\"");
-         return w;
-      }
-   }
-
-   public Object remove(String key) {
-      return this.map.remove(key);
-   }
-
-   public boolean similar(Object other) {
-      try {
-         if (!(other instanceof JSONObject)) {
-            return false;
-         } else if (!this.keySet().equals(((JSONObject)other).keySet())) {
-            return false;
-         } else {
-            for (Entry<String, ?> entry : this.entrySet()) {
-               String name = entry.getKey();
-               Object valueThis = entry.getValue();
-               Object valueOther = ((JSONObject)other).get(name);
-               if (valueThis != valueOther) {
-                  if (valueThis == null) {
-                     return false;
-                  }
-
-                  if (valueThis instanceof JSONObject) {
-                     if (!((JSONObject)valueThis).similar(valueOther)) {
-                        return false;
-                     }
-                  } else if (valueThis instanceof JSONArray) {
-                     if (!((JSONArray)valueThis).similar(valueOther)) {
-                        return false;
-                     }
-                  } else if (valueThis instanceof Number && valueOther instanceof Number) {
-                     if (!isNumberSimilar((Number)valueThis, (Number)valueOther)) {
-                        return false;
-                     }
-                  } else if (valueThis instanceof JSONString && valueOther instanceof JSONString) {
-                     if (!((JSONString)valueThis).toJSONString().equals(((JSONString)valueOther).toJSONString())) {
-                        return false;
-                     }
-                  } else if (!valueThis.equals(valueOther)) {
-                     return false;
-                  }
-               }
-            }
-
-            return true;
-         }
-      } catch (Throwable var7) {
-         return false;
-      }
-   }
-
-   static boolean isNumberSimilar(Number l, Number r) {
-      if (numberIsFinite(l) && numberIsFinite(r)) {
-         if (l.getClass().equals(r.getClass()) && l instanceof Comparable) {
-            int compareTo = ((Comparable)l).compareTo(r);
-            return compareTo == 0;
-         } else {
-            BigDecimal lBigDecimal = objectToBigDecimal(l, null, false);
-            BigDecimal rBigDecimal = objectToBigDecimal(r, null, false);
-            return lBigDecimal != null && rBigDecimal != null ? lBigDecimal.compareTo(rBigDecimal) == 0 : false;
-         }
-      } else {
-         return false;
-      }
-   }
-
-   private static boolean numberIsFinite(Number n) {
-      return !(n instanceof Double) || !((Double)n).isInfinite() && !((Double)n).isNaN()
-         ? !(n instanceof Float) || !((Float)n).isInfinite() && !((Float)n).isNaN()
-         : false;
-   }
-
-   protected static boolean isDecimalNotation(String val) {
-      return val.indexOf(46) > -1 || val.indexOf(101) > -1 || val.indexOf(69) > -1 || "-0".equals(val);
-   }
-
-   public static Object stringToValue(String string) {
-      if ("".equals(string)) {
-         return string;
-      } else if ("true".equalsIgnoreCase(string)) {
-         return Boolean.TRUE;
-      } else if ("false".equalsIgnoreCase(string)) {
-         return Boolean.FALSE;
-      } else if ("null".equalsIgnoreCase(string)) {
-         return NULL;
-      } else {
-         char initial = string.charAt(0);
-         if (initial >= '0' && initial <= '9' || initial == '-') {
-            try {
-               return stringToNumber(string);
-            } catch (Exception var3) {
-            }
-         }
-
-         return string;
-      }
-   }
-
-   protected static Number stringToNumber(String val) throws NumberFormatException {
-      char initial = val.charAt(0);
-      if ((initial < '0' || initial > '9') && initial != '-') {
-         throw new NumberFormatException("val [" + val + "] is not a valid number.");
-      } else if (isDecimalNotation(val)) {
-         try {
-            BigDecimal bd = new BigDecimal(val);
-            return (Number)(initial == '-' && BigDecimal.ZERO.compareTo(bd) == 0 ? -0.0 : bd);
-         } catch (NumberFormatException var5) {
-            try {
-               Double d = Double.valueOf(val);
-               if (!d.isNaN() && !d.isInfinite()) {
-                  return d;
-               } else {
-                  throw new NumberFormatException("val [" + val + "] is not a valid number.");
-               }
-            } catch (NumberFormatException var4) {
-               throw new NumberFormatException("val [" + val + "] is not a valid number.");
-            }
-         }
-      } else {
-         if (initial == '0' && val.length() > 1) {
-            char at1 = val.charAt(1);
-            if (at1 >= '0' && at1 <= '9') {
-               throw new NumberFormatException("val [" + val + "] is not a valid number.");
-            }
-         } else if (initial == '-' && val.length() > 2) {
-            char at1 = val.charAt(1);
-            char at2 = val.charAt(2);
-            if (at1 == '0' && at2 >= '0' && at2 <= '9') {
-               throw new NumberFormatException("val [" + val + "] is not a valid number.");
-            }
-         }
-
-         BigInteger bi = new BigInteger(val);
-         if (bi.bitLength() <= 31) {
-            return bi.intValue();
-         } else {
-            return (Number)(bi.bitLength() <= 63 ? bi.longValue() : bi);
-         }
-      }
-   }
-
-   public static void testValidity(Object o) throws JSONException {
-      if (o instanceof Number && !numberIsFinite((Number)o)) {
-         throw new JSONException("JSON does not allow non-finite numbers.");
-      }
-   }
-
-   public JSONArray toJSONArray(JSONArray names) throws JSONException {
-      if (names != null && !names.isEmpty()) {
-         JSONArray ja = new JSONArray();
-
-         for (int i = 0; i < names.length(); i++) {
-            ja.put(this.opt(names.getString(i)));
-         }
-
-         return ja;
-      } else {
-         return null;
-      }
-   }
-
-   @Override
-   public String toString() {
-      try {
-         return this.toString(0);
-      } catch (Exception var2) {
-         return null;
-      }
-   }
-
-   public String toString(int indentFactor) throws JSONException {
-      int initialSize = this.map.size() * 6;
-      Writer w = new StringBuilderWriter(Math.max(initialSize, 16));
-      return this.write(w, indentFactor, 0).toString();
-   }
-
-   public static String valueToString(Object value) throws JSONException {
-      return JSONWriter.valueToString(value);
-   }
-
-   public static Object wrap(Object object) {
-      return wrap(object, null);
-   }
-
-   static Object wrap(Object object, int recursionDepth, JSONParserConfiguration jsonParserConfiguration) {
-      return wrap(object, null, recursionDepth, jsonParserConfiguration);
-   }
-
-   private static Object wrap(Object object, Set<Object> objectsRecord) {
-      return wrap(object, objectsRecord, 0, new JSONParserConfiguration());
-   }
-
-   private static Object wrap(Object object, Set<Object> objectsRecord, int recursionDepth, JSONParserConfiguration jsonParserConfiguration) {
-      try {
-         if (NULL.equals(object)) {
-            return NULL;
-         } else if (object instanceof JSONObject
-            || object instanceof JSONArray
-            || NULL.equals(object)
-            || object instanceof JSONString
-            || object instanceof Byte
-            || object instanceof Character
-            || object instanceof Short
-            || object instanceof Integer
-            || object instanceof Long
-            || object instanceof Boolean
-            || object instanceof Float
-            || object instanceof Double
-            || object instanceof String
-            || object instanceof BigInteger
-            || object instanceof BigDecimal
-            || object instanceof Enum) {
-            return object;
-         } else if (object instanceof Collection) {
-            Collection<?> coll = (Collection<?>)object;
-            return new JSONArray(coll, recursionDepth, jsonParserConfiguration);
-         } else if (object.getClass().isArray()) {
-            return new JSONArray(object);
-         } else if (object instanceof Map) {
-            Map<?, ?> map = (Map<?, ?>)object;
-            return new JSONObject(map, recursionDepth, jsonParserConfiguration);
-         } else {
-            Package objectPackage = object.getClass().getPackage();
-            String objectPackageName = objectPackage != null ? objectPackage.getName() : "";
-            if (objectPackageName.startsWith("java.") || objectPackageName.startsWith("javax.") || object.getClass().getClassLoader() == null) {
-               return object.toString();
-            } else {
-               return objectsRecord != null ? new JSONObject(object, objectsRecord) : new JSONObject(object);
-            }
-         }
-      } catch (JSONException var6) {
-         throw var6;
-      } catch (Exception var7) {
-         return null;
-      }
-   }
-
-   public Writer write(Writer writer) throws JSONException {
-      return this.write(writer, 0, 0);
-   }
-
-   static final Writer writeValue(Writer writer, Object value, int indentFactor, int indent) throws JSONException, IOException {
-      if (value == null || value.equals(null)) {
-         writer.write("null");
-      } else if (value instanceof JSONString) {
-         Object o;
-         try {
-            o = ((JSONString)value).toJSONString();
-         } catch (Exception var6) {
-            throw new JSONException(var6);
-         }
-
-         writer.write(o != null ? o.toString() : quote(value.toString()));
-      } else {
-         if (value instanceof String) {
-            quote(value.toString(), writer);
-            return writer;
-         }
-
-         if (value instanceof Number) {
-            String numberAsString = numberToString((Number)value);
-            if (NUMBER_PATTERN.matcher(numberAsString).matches()) {
-               writer.write(numberAsString);
-            } else {
-               quote(numberAsString, writer);
-            }
-         } else if (value instanceof Boolean) {
-            writer.write(value.toString());
-         } else if (value instanceof Enum) {
-            writer.write(quote(((Enum)value).name()));
-         } else if (value instanceof JSONObject) {
-            ((JSONObject)value).write(writer, indentFactor, indent);
-         } else if (value instanceof JSONArray) {
-            ((JSONArray)value).write(writer, indentFactor, indent);
-         } else if (value instanceof Map) {
-            Map<?, ?> map = (Map<?, ?>)value;
-            new JSONObject(map).write(writer, indentFactor, indent);
-         } else if (value instanceof Collection) {
-            Collection<?> coll = (Collection<?>)value;
-            new JSONArray(coll).write(writer, indentFactor, indent);
-         } else if (value.getClass().isArray()) {
-            new JSONArray(value).write(writer, indentFactor, indent);
-         } else {
-            quote(value.toString(), writer);
-         }
-      }
-
-      return writer;
-   }
-
-   static final void indent(Writer writer, int indent) throws IOException {
-      for (int i = 0; i < indent; i++) {
-         writer.write(32);
-      }
-   }
-
-   public Writer write(Writer writer, int indentFactor, int indent) throws JSONException {
-      try {
-         boolean needsComma = false;
-         int length = this.length();
-         writer.write(123);
-         if (length == 1) {
-            Entry<String, ?> entry = this.entrySet().iterator().next();
-            String key = entry.getKey();
-            writer.write(quote(key));
-            writer.write(58);
-            if (indentFactor > 0) {
-               writer.write(32);
-            }
-
-            try {
-               writeValue(writer, entry.getValue(), indentFactor, indent);
-            } catch (Exception var12) {
-               throw new JSONException("Unable to write JSONObject value for key: " + key, var12);
-            }
-         } else if (length != 0) {
-            int newIndent = indent + indentFactor;
-
-            for (Entry<String, ?> entry : this.entrySet()) {
-               if (needsComma) {
-                  writer.write(44);
-               }
-
-               if (indentFactor > 0) {
-                  writer.write(10);
-               }
-
-               indent(writer, newIndent);
-               String key = entry.getKey();
-               writer.write(quote(key));
-               writer.write(58);
-               if (indentFactor > 0) {
-                  writer.write(32);
-               }
-
-               try {
-                  writeValue(writer, entry.getValue(), indentFactor, newIndent);
-               } catch (Exception var11) {
-                  throw new JSONException("Unable to write JSONObject value for key: " + key, var11);
-               }
-
-               needsComma = true;
-            }
-
-            if (indentFactor > 0) {
-               writer.write(10);
-            }
-
-            indent(writer, indent);
-         }
-
-         writer.write(125);
-         return writer;
-      } catch (IOException var13) {
-         throw new JSONException(var13);
-      }
-   }
-
-   public Map<String, Object> toMap() {
-      Map<String, Object> results = new HashMap<>();
-
-      for (Entry<String, Object> entry : this.entrySet()) {
-         Object value;
-         if (entry.getValue() == null || NULL.equals(entry.getValue())) {
-            value = null;
-         } else if (entry.getValue() instanceof JSONObject) {
-            value = ((JSONObject)entry.getValue()).toMap();
-         } else if (entry.getValue() instanceof JSONArray) {
-            value = ((JSONArray)entry.getValue()).toList();
-         } else {
-            value = entry.getValue();
-         }
-
-         results.put(entry.getKey(), value);
-      }
-
-      return results;
-   }
-
-   private static JSONException wrongValueFormatException(String key, String valueType, Object value, Throwable cause) {
-      if (value == null) {
-         return new JSONException("JSONObject[" + quote(key) + "] is not a " + valueType + " (null).", cause);
-      } else {
-         return !(value instanceof Map) && !(value instanceof Iterable) && !(value instanceof JSONObject)
-            ? new JSONException("JSONObject[" + quote(key) + "] is not a " + valueType + " (" + value.getClass() + " : " + value + ").", cause)
-            : new JSONException("JSONObject[" + quote(key) + "] is not a " + valueType + " (" + value.getClass() + ").", cause);
-      }
-   }
-
-   private static JSONException recursivelyDefinedObjectException(String key) {
-      return new JSONException("JavaBean object contains recursively defined member variable of key " + quote(key));
-   }
-
-   private static String removeLeadingZerosOfNumber(String value) {
-      if (value.equals("-")) {
-         return value;
-      } else {
-         boolean negativeFirstChar = value.charAt(0) == '-';
-
-         for (int counter = negativeFirstChar ? 1 : 0; counter < value.length(); counter++) {
-            if (value.charAt(counter) != '0') {
-               if (negativeFirstChar) {
-                  return "-".concat(value.substring(counter));
-               }
-
-               return value.substring(counter);
-            }
-         }
-
-         return negativeFirstChar ? "-0" : "0";
-      }
-   }
-
-   private static final class Null {
-      private Null() {
-      }
-
-      @Override
-      protected final Object clone() {
-         return this;
-      }
-
-      @Override
-      public boolean equals(Object object) {
-         return object == null || object == this;
-      }
-
-      @Override
-      public int hashCode() {
-         return 0;
-      }
-
-      @Override
-      public String toString() {
-         return "null";
-      }
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/JSONParserConfiguration.java b/dev/hexedhero/hivechecker/shaded/json/JSONParserConfiguration.java
deleted file mode 100644
index 34ed699..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/JSONParserConfiguration.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-public class JSONParserConfiguration extends ParserConfiguration {
-   private boolean overwriteDuplicateKey = false;
-   private boolean useNativeNulls;
-   private boolean strictMode;
-
-   protected JSONParserConfiguration clone() {
-      JSONParserConfiguration clone = new JSONParserConfiguration();
-      clone.overwriteDuplicateKey = this.overwriteDuplicateKey;
-      clone.strictMode = this.strictMode;
-      clone.maxNestingDepth = this.maxNestingDepth;
-      clone.keepStrings = this.keepStrings;
-      clone.useNativeNulls = this.useNativeNulls;
-      return clone;
-   }
-
-   public JSONParserConfiguration withMaxNestingDepth(int maxNestingDepth) {
-      JSONParserConfiguration clone = this.clone();
-      clone.maxNestingDepth = maxNestingDepth;
-      return clone;
-   }
-
-   public JSONParserConfiguration withOverwriteDuplicateKey(boolean overwriteDuplicateKey) {
-      JSONParserConfiguration clone = this.clone();
-      clone.overwriteDuplicateKey = overwriteDuplicateKey;
-      return clone;
-   }
-
-   public JSONParserConfiguration withUseNativeNulls(boolean useNativeNulls) {
-      JSONParserConfiguration clone = this.clone();
-      clone.useNativeNulls = useNativeNulls;
-      return clone;
-   }
-
-   public JSONParserConfiguration withStrictMode() {
-      return this.withStrictMode(true);
-   }
-
-   public JSONParserConfiguration withStrictMode(boolean mode) {
-      JSONParserConfiguration clone = this.clone();
-      clone.strictMode = mode;
-      return clone;
-   }
-
-   public boolean isOverwriteDuplicateKey() {
-      return this.overwriteDuplicateKey;
-   }
-
-   public boolean isUseNativeNulls() {
-      return this.useNativeNulls;
-   }
-
-   public boolean isStrictMode() {
-      return this.strictMode;
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/JSONPointer.java b/dev/hexedhero/hivechecker/shaded/json/JSONPointer.java
deleted file mode 100644
index dccac24..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/JSONPointer.java
+++ /dev/null
@@ -1,159 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-import java.io.UnsupportedEncodingException;
-import java.net.URLDecoder;
-import java.net.URLEncoder;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-public class JSONPointer {
-   private static final String ENCODING = "utf-8";
-   private final List<String> refTokens;
-
-   public static JSONPointer.Builder builder() {
-      return new JSONPointer.Builder();
-   }
-
-   public JSONPointer(String pointer) {
-      if (pointer == null) {
-         throw new NullPointerException("pointer cannot be null");
-      } else if (!pointer.isEmpty() && !pointer.equals("#")) {
-         String refs;
-         if (pointer.startsWith("#/")) {
-            refs = pointer.substring(2);
-
-            try {
-               refs = URLDecoder.decode(refs, "utf-8");
-            } catch (UnsupportedEncodingException var6) {
-               throw new RuntimeException(var6);
-            }
-         } else {
-            if (!pointer.startsWith("/")) {
-               throw new IllegalArgumentException("a JSON pointer should start with '/' or '#/'");
-            }
-
-            refs = pointer.substring(1);
-         }
-
-         this.refTokens = new ArrayList<>();
-         int slashIdx = -1;
-         int prevSlashIdx = 0;
-
-         do {
-            prevSlashIdx = slashIdx + 1;
-            slashIdx = refs.indexOf(47, prevSlashIdx);
-            if (prevSlashIdx == slashIdx || prevSlashIdx == refs.length()) {
-               this.refTokens.add("");
-            } else if (slashIdx >= 0) {
-               String token = refs.substring(prevSlashIdx, slashIdx);
-               this.refTokens.add(unescape(token));
-            } else {
-               String token = refs.substring(prevSlashIdx);
-               this.refTokens.add(unescape(token));
-            }
-         } while (slashIdx >= 0);
-      } else {
-         this.refTokens = Collections.emptyList();
-      }
-   }
-
-   public JSONPointer(List<String> refTokens) {
-      this.refTokens = new ArrayList<>(refTokens);
-   }
-
-   private static String unescape(String token) {
-      return token.replace("~1", "/").replace("~0", "~");
-   }
-
-   public Object queryFrom(Object document) throws JSONPointerException {
-      if (this.refTokens.isEmpty()) {
-         return document;
-      } else {
-         Object current = document;
-
-         for (String token : this.refTokens) {
-            if (current instanceof JSONObject) {
-               current = ((JSONObject)current).opt(unescape(token));
-            } else {
-               if (!(current instanceof JSONArray)) {
-                  throw new JSONPointerException(String.format("value [%s] is not an array or object therefore its key %s cannot be resolved", current, token));
-               }
-
-               current = readByIndexToken(current, token);
-            }
-         }
-
-         return current;
-      }
-   }
-
-   private static Object readByIndexToken(Object current, String indexToken) throws JSONPointerException {
-      try {
-         int index = Integer.parseInt(indexToken);
-         JSONArray currentArr = (JSONArray)current;
-         if (index >= currentArr.length()) {
-            throw new JSONPointerException(String.format("index %s is out of bounds - the array has %d elements", indexToken, currentArr.length()));
-         } else {
-            try {
-               return currentArr.get(index);
-            } catch (JSONException var5) {
-               throw new JSONPointerException("Error reading value at index position " + index, var5);
-            }
-         }
-      } catch (NumberFormatException var6) {
-         throw new JSONPointerException(String.format("%s is not an array index", indexToken), var6);
-      }
-   }
-
-   @Override
-   public String toString() {
-      StringBuilder rval = new StringBuilder("");
-
-      for (String token : this.refTokens) {
-         rval.append('/').append(escape(token));
-      }
-
-      return rval.toString();
-   }
-
-   private static String escape(String token) {
-      return token.replace("~", "~0").replace("/", "~1");
-   }
-
-   public String toURIFragment() {
-      try {
-         StringBuilder rval = new StringBuilder("#");
-
-         for (String token : this.refTokens) {
-            rval.append('/').append(URLEncoder.encode(token, "utf-8"));
-         }
-
-         return rval.toString();
-      } catch (UnsupportedEncodingException var4) {
-         throw new RuntimeException(var4);
-      }
-   }
-
-   public static class Builder {
-      private final List<String> refTokens = new ArrayList<>();
-
-      public JSONPointer build() {
-         return new JSONPointer(this.refTokens);
-      }
-
-      public JSONPointer.Builder append(String token) {
-         if (token == null) {
-            throw new NullPointerException("token cannot be null");
-         } else {
-            this.refTokens.add(token);
-            return this;
-         }
-      }
-
-      public JSONPointer.Builder append(int arrayIndex) {
-         this.refTokens.add(String.valueOf(arrayIndex));
-         return this;
-      }
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/JSONPointerException.java b/dev/hexedhero/hivechecker/shaded/json/JSONPointerException.java
deleted file mode 100644
index 6e00a45..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/JSONPointerException.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-public class JSONPointerException extends JSONException {
-   private static final long serialVersionUID = 8872944667561856751L;
-
-   public JSONPointerException(String message) {
-      super(message);
-   }
-
-   public JSONPointerException(String message, Throwable cause) {
-      super(message, cause);
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/JSONPropertyIgnore.java b/dev/hexedhero/hivechecker/shaded/json/JSONPropertyIgnore.java
deleted file mode 100644
index 23b60ae..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/JSONPropertyIgnore.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-@Documented
-@Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.METHOD)
-public @interface JSONPropertyIgnore {
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/JSONPropertyName.java b/dev/hexedhero/hivechecker/shaded/json/JSONPropertyName.java
deleted file mode 100644
index 66d5cc9..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/JSONPropertyName.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-@Documented
-@Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.METHOD)
-public @interface JSONPropertyName {
-   String value();
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/JSONString.java b/dev/hexedhero/hivechecker/shaded/json/JSONString.java
deleted file mode 100644
index 8121398..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/JSONString.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-public interface JSONString {
-   String toJSONString();
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/JSONTokener.java b/dev/hexedhero/hivechecker/shaded/json/JSONTokener.java
deleted file mode 100644
index 873baef..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/JSONTokener.java
+++ /dev/null
@@ -1,400 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.io.StringReader;
-import java.nio.charset.Charset;
-
-public class JSONTokener {
-   private long character;
-   private boolean eof;
-   private long index;
-   private long line;
-   private char previous;
-   private final Reader reader;
-   private boolean usePrevious;
-   private long characterPreviousLine;
-   private JSONParserConfiguration jsonParserConfiguration;
-
-   public JSONTokener(Reader reader) {
-      this(reader, new JSONParserConfiguration());
-   }
-
-   public JSONTokener(Reader reader, JSONParserConfiguration jsonParserConfiguration) {
-      this.jsonParserConfiguration = jsonParserConfiguration;
-      this.reader = (Reader)(reader.markSupported() ? reader : new BufferedReader(reader));
-      this.eof = false;
-      this.usePrevious = false;
-      this.previous = 0;
-      this.index = 0L;
-      this.character = 1L;
-      this.characterPreviousLine = 0L;
-      this.line = 1L;
-   }
-
-   public JSONTokener(InputStream inputStream) {
-      this(inputStream, new JSONParserConfiguration());
-   }
-
-   public JSONTokener(InputStream inputStream, JSONParserConfiguration jsonParserConfiguration) {
-      this(new InputStreamReader(inputStream, Charset.forName("UTF-8")), jsonParserConfiguration);
-   }
-
-   public JSONTokener(String source) {
-      this(new StringReader(source));
-   }
-
-   public JSONTokener(String source, JSONParserConfiguration jsonParserConfiguration) {
-      this(new StringReader(source), jsonParserConfiguration);
-   }
-
-   public JSONParserConfiguration getJsonParserConfiguration() {
-      return this.jsonParserConfiguration;
-   }
-
-   @Deprecated
-   public void setJsonParserConfiguration(JSONParserConfiguration jsonParserConfiguration) {
-      this.jsonParserConfiguration = jsonParserConfiguration;
-   }
-
-   public void back() throws JSONException {
-      if (!this.usePrevious && this.index > 0L) {
-         this.decrementIndexes();
-         this.usePrevious = true;
-         this.eof = false;
-      } else {
-         throw new JSONException("Stepping back two steps is not supported");
-      }
-   }
-
-   private void decrementIndexes() {
-      this.index--;
-      if (this.previous == '\r' || this.previous == '\n') {
-         this.line--;
-         this.character = this.characterPreviousLine;
-      } else if (this.character > 0L) {
-         this.character--;
-      }
-   }
-
-   public static int dehexchar(char c) {
-      if (c >= '0' && c <= '9') {
-         return c - 48;
-      } else if (c >= 'A' && c <= 'F') {
-         return c - 55;
-      } else {
-         return c >= 97 && c <= 102 ? c - 87 : -1;
-      }
-   }
-
-   public boolean end() {
-      return this.eof && !this.usePrevious;
-   }
-
-   public boolean more() throws JSONException {
-      if (this.usePrevious) {
-         return true;
-      } else {
-         try {
-            this.reader.mark(1);
-         } catch (IOException var3) {
-            throw new JSONException("Unable to preserve stream position", var3);
-         }
-
-         try {
-            if (this.reader.read() <= 0) {
-               this.eof = true;
-               return false;
-            } else {
-               this.reader.reset();
-               return true;
-            }
-         } catch (IOException var2) {
-            throw new JSONException("Unable to read the next character from the stream", var2);
-         }
-      }
-   }
-
-   public char next() throws JSONException {
-      int c;
-      if (this.usePrevious) {
-         this.usePrevious = false;
-         c = this.previous;
-      } else {
-         try {
-            c = this.reader.read();
-         } catch (IOException var3) {
-            throw new JSONException(var3);
-         }
-      }
-
-      if (c <= 0) {
-         this.eof = true;
-         return '\u0000';
-      } else {
-         this.incrementIndexes(c);
-         this.previous = (char)c;
-         return this.previous;
-      }
-   }
-
-   protected char getPrevious() {
-      return this.previous;
-   }
-
-   private void incrementIndexes(int c) {
-      if (c > 0) {
-         this.index++;
-         if (c == 13) {
-            this.line++;
-            this.characterPreviousLine = this.character;
-            this.character = 0L;
-         } else if (c == 10) {
-            if (this.previous != '\r') {
-               this.line++;
-               this.characterPreviousLine = this.character;
-            }
-
-            this.character = 0L;
-         } else {
-            this.character++;
-         }
-      }
-   }
-
-   public char next(char c) throws JSONException {
-      char n = this.next();
-      if (n != c) {
-         if (n > 0) {
-            throw this.syntaxError("Expected '" + c + "' and instead saw '" + n + "'");
-         } else {
-            throw this.syntaxError("Expected '" + c + "' and instead saw ''");
-         }
-      } else {
-         return n;
-      }
-   }
-
-   public String next(int n) throws JSONException {
-      if (n == 0) {
-         return "";
-      } else {
-         char[] chars = new char[n];
-
-         for (int pos = 0; pos < n; pos++) {
-            chars[pos] = this.next();
-            if (this.end()) {
-               throw this.syntaxError("Substring bounds error");
-            }
-         }
-
-         return new String(chars);
-      }
-   }
-
-   public char nextClean() throws JSONException {
-      char c;
-      do {
-         c = this.next();
-      } while (c != 0 && c <= ' ');
-
-      return c;
-   }
-
-   public String nextString(char quote) throws JSONException {
-      StringBuilder sb = new StringBuilder();
-
-      while (true) {
-         char c = this.next();
-         switch (c) {
-            case '\u0000':
-            case '\n':
-            case '\r':
-               throw this.syntaxError("Unterminated string. Character with int code " + c + " is not allowed within a quoted string.");
-            case '\\':
-               c = this.next();
-               switch (c) {
-                  case '"':
-                  case '\'':
-                  case '/':
-                  case '\\':
-                     sb.append(c);
-                     continue;
-                  case 'b':
-                     sb.append('\b');
-                     continue;
-                  case 'f':
-                     sb.append('\f');
-                     continue;
-                  case 'n':
-                     sb.append('\n');
-                     continue;
-                  case 'r':
-                     sb.append('\r');
-                     continue;
-                  case 't':
-                     sb.append('\t');
-                     continue;
-                  case 'u':
-                     String next = this.next(4);
-
-                     try {
-                        sb.append((char)Integer.parseInt(next, 16));
-                        continue;
-                     } catch (NumberFormatException var6) {
-                        throw this.syntaxError("Illegal escape. \\u must be followed by a 4 digit hexadecimal number. \\" + next + " is not valid.", var6);
-                     }
-                  default:
-                     throw this.syntaxError("Illegal escape. Escape sequence  \\" + c + " is not valid.");
-               }
-            default:
-               if (c == quote) {
-                  return sb.toString();
-               }
-
-               sb.append(c);
-         }
-      }
-   }
-
-   public String nextTo(char delimiter) throws JSONException {
-      StringBuilder sb = new StringBuilder();
-
-      while (true) {
-         char c = this.next();
-         if (c == delimiter || c == 0 || c == '\n' || c == '\r') {
-            if (c != 0) {
-               this.back();
-            }
-
-            return sb.toString().trim();
-         }
-
-         sb.append(c);
-      }
-   }
-
-   public String nextTo(String delimiters) throws JSONException {
-      StringBuilder sb = new StringBuilder();
-
-      while (true) {
-         char c = this.next();
-         if (delimiters.indexOf(c) >= 0 || c == 0 || c == '\n' || c == '\r') {
-            if (c != 0) {
-               this.back();
-            }
-
-            return sb.toString().trim();
-         }
-
-         sb.append(c);
-      }
-   }
-
-   public Object nextValue() throws JSONException {
-      char c = this.nextClean();
-      switch (c) {
-         case '[':
-            this.back();
-
-            try {
-               return new JSONArray(this, this.jsonParserConfiguration);
-            } catch (StackOverflowError var4) {
-               throw new JSONException("JSON Array or Object depth too large to process.", var4);
-            }
-         case '{':
-            this.back();
-
-            try {
-               return new JSONObject(this, this.jsonParserConfiguration);
-            } catch (StackOverflowError var3) {
-               throw new JSONException("JSON Array or Object depth too large to process.", var3);
-            }
-         default:
-            return this.nextSimpleValue(c);
-      }
-   }
-
-   Object nextSimpleValue(char c) {
-      if (this.jsonParserConfiguration != null && this.jsonParserConfiguration.isStrictMode() && c == '\'') {
-         throw this.syntaxError("Strict mode error: Single quoted strings are not allowed");
-      } else {
-         switch (c) {
-            case '"':
-            case '\'':
-               return this.nextString(c);
-            default:
-               StringBuilder sb;
-               for (sb = new StringBuilder(); c >= ' ' && ",:]}/\\\"[{;=#".indexOf(c) < 0; c = this.next()) {
-                  sb.append(c);
-               }
-
-               if (!this.eof) {
-                  this.back();
-               }
-
-               String string = sb.toString().trim();
-               if ("".equals(string)) {
-                  throw this.syntaxError("Missing value");
-               } else {
-                  Object obj = JSONObject.stringToValue(string);
-                  if (this.jsonParserConfiguration != null && this.jsonParserConfiguration.isStrictMode() && obj instanceof String) {
-                     throw this.syntaxError(String.format("Strict mode error: Value '%s' is not surrounded by quotes", obj));
-                  } else {
-                     return obj;
-                  }
-               }
-         }
-      }
-   }
-
-   public char skipTo(char to) throws JSONException {
-      char c;
-      try {
-         long startIndex = this.index;
-         long startCharacter = this.character;
-         long startLine = this.line;
-         this.reader.mark(1000000);
-
-         do {
-            c = this.next();
-            if (c == 0) {
-               this.reader.reset();
-               this.index = startIndex;
-               this.character = startCharacter;
-               this.line = startLine;
-               return '\u0000';
-            }
-         } while (c != to);
-
-         this.reader.mark(1);
-      } catch (IOException var9) {
-         throw new JSONException(var9);
-      }
-
-      this.back();
-      return c;
-   }
-
-   public JSONException syntaxError(String message) {
-      return new JSONException(message + this.toString());
-   }
-
-   public JSONException syntaxError(String message, Throwable causedBy) {
-      return new JSONException(message + this.toString(), causedBy);
-   }
-
-   @Override
-   public String toString() {
-      return " at " + this.index + " [character " + this.character + " line " + this.line + "]";
-   }
-
-   public void close() throws IOException {
-      if (this.reader != null) {
-         this.reader.close();
-      }
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/JSONWriter.java b/dev/hexedhero/hivechecker/shaded/json/JSONWriter.java
deleted file mode 100644
index d4d8871..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/JSONWriter.java
+++ /dev/null
@@ -1,196 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-import java.io.IOException;
-import java.util.Collection;
-import java.util.Map;
-
-public class JSONWriter {
-   private static final int maxdepth = 200;
-   private boolean comma = false;
-   protected char mode = 'i';
-   private final JSONObject[] stack = new JSONObject[200];
-   private int top = 0;
-   protected Appendable writer;
-
-   public JSONWriter(Appendable w) {
-      this.writer = w;
-   }
-
-   private JSONWriter append(String string) throws JSONException {
-      if (string == null) {
-         throw new JSONException("Null pointer");
-      } else if (this.mode != 'o' && this.mode != 'a') {
-         throw new JSONException("Value out of sequence.");
-      } else {
-         try {
-            if (this.comma && this.mode == 'a') {
-               this.writer.append(',');
-            }
-
-            this.writer.append(string);
-         } catch (IOException var3) {
-            throw new JSONException(var3);
-         }
-
-         if (this.mode == 'o') {
-            this.mode = 'k';
-         }
-
-         this.comma = true;
-         return this;
-      }
-   }
-
-   public JSONWriter array() throws JSONException {
-      if (this.mode != 'i' && this.mode != 'o' && this.mode != 'a') {
-         throw new JSONException("Misplaced array.");
-      } else {
-         this.push(null);
-         this.append("[");
-         this.comma = false;
-         return this;
-      }
-   }
-
-   private JSONWriter end(char m, char c) throws JSONException {
-      if (this.mode != m) {
-         throw new JSONException(m == 'a' ? "Misplaced endArray." : "Misplaced endObject.");
-      } else {
-         this.pop(m);
-
-         try {
-            this.writer.append(c);
-         } catch (IOException var4) {
-            throw new JSONException(var4);
-         }
-
-         this.comma = true;
-         return this;
-      }
-   }
-
-   public JSONWriter endArray() throws JSONException {
-      return this.end('a', ']');
-   }
-
-   public JSONWriter endObject() throws JSONException {
-      return this.end('k', '}');
-   }
-
-   public JSONWriter key(String string) throws JSONException {
-      if (string == null) {
-         throw new JSONException("Null key.");
-      } else if (this.mode == 'k') {
-         try {
-            JSONObject topObject = this.stack[this.top - 1];
-            if (topObject.has(string)) {
-               throw new JSONException("Duplicate key \"" + string + "\"");
-            } else {
-               topObject.put(string, true);
-               if (this.comma) {
-                  this.writer.append(',');
-               }
-
-               this.writer.append(JSONObject.quote(string));
-               this.writer.append(':');
-               this.comma = false;
-               this.mode = 'o';
-               return this;
-            }
-         } catch (IOException var3) {
-            throw new JSONException(var3);
-         }
-      } else {
-         throw new JSONException("Misplaced key.");
-      }
-   }
-
-   public JSONWriter object() throws JSONException {
-      if (this.mode == 'i') {
-         this.mode = 'o';
-      }
-
-      if (this.mode != 'o' && this.mode != 'a') {
-         throw new JSONException("Misplaced object.");
-      } else {
-         this.append("{");
-         this.push(new JSONObject());
-         this.comma = false;
-         return this;
-      }
-   }
-
-   private void pop(char c) throws JSONException {
-      if (this.top <= 0) {
-         throw new JSONException("Nesting error.");
-      } else {
-         char m = (char)(this.stack[this.top - 1] == null ? 97 : 107);
-         if (m != c) {
-            throw new JSONException("Nesting error.");
-         } else {
-            this.top--;
-            this.mode = (char)(this.top == 0 ? 100 : (this.stack[this.top - 1] == null ? 97 : 107));
-         }
-      }
-   }
-
-   private void push(JSONObject jo) throws JSONException {
-      if (this.top >= 200) {
-         throw new JSONException("Nesting too deep.");
-      } else {
-         this.stack[this.top] = jo;
-         this.mode = (char)(jo == null ? 97 : 107);
-         this.top++;
-      }
-   }
-
-   public static String valueToString(Object value) throws JSONException {
-      if (value == null || value.equals(null)) {
-         return "null";
-      } else if (value instanceof JSONString) {
-         String object;
-         try {
-            object = ((JSONString)value).toJSONString();
-         } catch (Exception var3) {
-            throw new JSONException(var3);
-         }
-
-         if (object != null) {
-            return object;
-         } else {
-            throw new JSONException("Bad value from toJSONString: " + object);
-         }
-      } else if (value instanceof Number) {
-         String numberAsString = JSONObject.numberToString((Number)value);
-         return JSONObject.NUMBER_PATTERN.matcher(numberAsString).matches() ? numberAsString : JSONObject.quote(numberAsString);
-      } else if (value instanceof Boolean || value instanceof JSONObject || value instanceof JSONArray) {
-         return value.toString();
-      } else if (value instanceof Map) {
-         Map<?, ?> map = (Map<?, ?>)value;
-         return new JSONObject(map).toString();
-      } else if (value instanceof Collection) {
-         Collection<?> coll = (Collection<?>)value;
-         return new JSONArray(coll).toString();
-      } else if (value.getClass().isArray()) {
-         return new JSONArray(value).toString();
-      } else {
-         return value instanceof Enum ? JSONObject.quote(((Enum)value).name()) : JSONObject.quote(value.toString());
-      }
-   }
-
-   public JSONWriter value(boolean b) throws JSONException {
-      return this.append(b ? "true" : "false");
-   }
-
-   public JSONWriter value(double d) throws JSONException {
-      return this.value(Double.valueOf(d));
-   }
-
-   public JSONWriter value(long l) throws JSONException {
-      return this.append(Long.toString(l));
-   }
-
-   public JSONWriter value(Object object) throws JSONException {
-      return this.append(valueToString(object));
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/ParserConfiguration.java b/dev/hexedhero/hivechecker/shaded/json/ParserConfiguration.java
deleted file mode 100644
index dc34f11..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/ParserConfiguration.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-public class ParserConfiguration {
-   public static final int UNDEFINED_MAXIMUM_NESTING_DEPTH = -1;
-   public static final int DEFAULT_MAXIMUM_NESTING_DEPTH = 512;
-   protected boolean keepStrings;
-   protected int maxNestingDepth;
-
-   public ParserConfiguration() {
-      this.keepStrings = false;
-      this.maxNestingDepth = 512;
-   }
-
-   protected ParserConfiguration(boolean keepStrings, int maxNestingDepth) {
-      this.keepStrings = keepStrings;
-      this.maxNestingDepth = maxNestingDepth;
-   }
-
-   protected ParserConfiguration clone() {
-      return new ParserConfiguration(this.keepStrings, this.maxNestingDepth);
-   }
-
-   public boolean isKeepStrings() {
-      return this.keepStrings;
-   }
-
-   public <T extends ParserConfiguration> T withKeepStrings(boolean newVal) {
-      T newConfig = (T)this.clone();
-      newConfig.keepStrings = newVal;
-      return newConfig;
-   }
-
-   public int getMaxNestingDepth() {
-      return this.maxNestingDepth;
-   }
-
-   public <T extends ParserConfiguration> T withMaxNestingDepth(int maxNestingDepth) {
-      T newConfig = (T)this.clone();
-      if (maxNestingDepth > -1) {
-         newConfig.maxNestingDepth = maxNestingDepth;
-      } else {
-         newConfig.maxNestingDepth = -1;
-      }
-
-      return newConfig;
-   }
-}
diff --git a/dev/hexedhero/hivechecker/shaded/json/StringBuilderWriter.java b/dev/hexedhero/hivechecker/shaded/json/StringBuilderWriter.java
deleted file mode 100644
index ecdcfd5..0000000
--- a/dev/hexedhero/hivechecker/shaded/json/StringBuilderWriter.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package dev.hexedhero.hivechecker.shaded.json;
-
-import java.io.IOException;
-import java.io.Writer;
-
-public class StringBuilderWriter extends Writer {
-   private final StringBuilder builder;
-
-   public StringBuilderWriter() {
-      this.builder = new StringBuilder();
-      this.lock = this.builder;
-   }
-
-   public StringBuilderWriter(int initialSize) {
-      this.builder = new StringBuilder(initialSize);
-      this.lock = this.builder;
-   }
-
-   @Override
-   public void write(int c) {
-      this.builder.append((char)c);
-   }
-
-   @Override
-   public void write(char[] cbuf, int offset, int length) {
-      if (offset < 0 || offset > cbuf.length || length < 0 || offset + length > cbuf.length || offset + length < 0) {
-         throw new IndexOutOfBoundsException();
-      } else if (length != 0) {
-         this.builder.append(cbuf, offset, length);
-      }
-   }
-
-   @Override
-   public void write(String str) {
-      this.builder.append(str);
-   }
-
-   @Override
-   public void write(String str, int offset, int length) {
-      this.builder.append(str, offset, offset + length);
-   }
-
-   public StringBuilderWriter append(CharSequence csq) {
-      this.write(String.valueOf(csq));
-      return this;
-   }
-
-   public StringBuilderWriter append(CharSequence csq, int start, int end) {
-      if (csq == null) {
-         csq = "null";
-      }
-
-      return this.append(csq.subSequence(start, end));
-   }
-
-   public StringBuilderWriter append(char c) {
-      this.write(c);
-      return this;
-   }
-
-   @Override
-   public String toString() {
-      return this.builder.toString();
-   }
-
-   @Override
-   public void flush() {
-   }
-
-   @Override
-   public void close() throws IOException {
-   }
-}
diff --git a/dev/hexedhero/hivechecker/utils/SkullCreator.java b/dev/hexedhero/hivechecker/utils/SkullCreator.java
index 463657e..19d4dbf 100644
--- a/dev/hexedhero/hivechecker/utils/SkullCreator.java
+++ b/dev/hexedhero/hivechecker/utils/SkullCreator.java
@@ -2,7 +2,8 @@ package dev.hexedhero.hivechecker.utils;
 
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.properties.Property;
-import dev.hexedhero.hivechecker.shaded.json.JSONObject;
+//import dev.hexedhero.hivechecker.shaded.json.JSONObject; // Luma - decompile
+import org.json.JSONObject; // Luma - decompile
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
